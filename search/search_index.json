{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Brel API Reference Welcome to the Brel API Reference. Click on one of the categories below to get started. Examples This page contains examples of how to use Brel. Filings The Filing is the main object in Brel. It contains all the information about a filing, including the facts and the components. Facts Facts are the atomic pieces of information that make up a filing. They are the actual values that business reports are made of. Components Components are a way to group facts together. They are used to represent the structure of a business report. QNames QNames are a way to identify facts and components. They are used to reference everything from concepts to dimensions and types. Brel Implementation If you wish to learn more about the implementation of Brel, you can read my Master's thesis or the source code .","title":"Home"},{"location":"#brel-api-reference","text":"Welcome to the Brel API Reference. Click on one of the categories below to get started.","title":"Brel API Reference"},{"location":"#examples","text":"This page contains examples of how to use Brel.","title":"Examples"},{"location":"#filings","text":"The Filing is the main object in Brel. It contains all the information about a filing, including the facts and the components.","title":"Filings"},{"location":"#facts","text":"Facts are the atomic pieces of information that make up a filing. They are the actual values that business reports are made of.","title":"Facts"},{"location":"#components","text":"Components are a way to group facts together. They are used to represent the structure of a business report.","title":"Components"},{"location":"#qnames","text":"QNames are a way to identify facts and components. They are used to reference everything from concepts to dimensions and types.","title":"QNames"},{"location":"#brel-implementation","text":"If you wish to learn more about the implementation of Brel, you can read my Master's thesis or the source code .","title":"Brel Implementation"},{"location":"Loading%20from%20EDGAR/","text":"Loading a filing from EDGAR The following steps are required to download a filing from EDGAR and load it into Brel: Search for the company's CIK on the SEC website . Specify if you want to download the 10-K, 10-Q, or 8-K filings. (optional) Specify the date of the filing. If not specified, the most recent filing will be downloaded. Example 1: Loading a filing and printing its facts Filings can be directly loaded from EDGAR using the brel.utils.open_edgar function. The following example loads the 10-K filing for Apple Inc. in 2020 and prints the first 10 facts. from brel.utils import open_edgar, pprint # Load a filing from EDGAR. In this case, the CIK is 320193 and the form is 10-K filing = open_edgar(cik=\"320193\", form=\"10-K\", year=2020) first_10_facts = filing.get_all_facts()[:10] pprint(first_10_facts) Example 2: Loading a filing with a date The following example loads the 10-K filing for Apple Inc. on the 30th of September, 2023 and prints the first 10 facts. The format of the date is \"YYYY-MM-DD\". Therefore the date \"30th of September, 2023\" is \"2023-09-30\". Important : If Brel does not find the filing for the given date, it will raise a ValueError . Also, the date refers to the date on the report, not the date the report was filed. from brel.utils import open_edgar, pprint # Load a filing from EDGAR. # - CIK is 320193 # - form is 10-K # - date is the 30th of September, 2023. filing = open_edgar(cik=\"320193\", form=\"10-K\", date=\"2023-09-30\")","title":"EDGAR"},{"location":"Loading%20from%20EDGAR/#loading-a-filing-from-edgar","text":"The following steps are required to download a filing from EDGAR and load it into Brel: Search for the company's CIK on the SEC website . Specify if you want to download the 10-K, 10-Q, or 8-K filings. (optional) Specify the date of the filing. If not specified, the most recent filing will be downloaded.","title":"Loading a filing from EDGAR"},{"location":"Loading%20from%20EDGAR/#example-1-loading-a-filing-and-printing-its-facts","text":"Filings can be directly loaded from EDGAR using the brel.utils.open_edgar function. The following example loads the 10-K filing for Apple Inc. in 2020 and prints the first 10 facts. from brel.utils import open_edgar, pprint # Load a filing from EDGAR. In this case, the CIK is 320193 and the form is 10-K filing = open_edgar(cik=\"320193\", form=\"10-K\", year=2020) first_10_facts = filing.get_all_facts()[:10] pprint(first_10_facts)","title":"Example 1: Loading a filing and printing its facts"},{"location":"Loading%20from%20EDGAR/#example-2-loading-a-filing-with-a-date","text":"The following example loads the 10-K filing for Apple Inc. on the 30th of September, 2023 and prints the first 10 facts. The format of the date is \"YYYY-MM-DD\". Therefore the date \"30th of September, 2023\" is \"2023-09-30\". Important : If Brel does not find the filing for the given date, it will raise a ValueError . Also, the date refers to the date on the report, not the date the report was filed. from brel.utils import open_edgar, pprint # Load a filing from EDGAR. # - CIK is 320193 # - form is 10-K # - date is the 30th of September, 2023. filing = open_edgar(cik=\"320193\", form=\"10-K\", date=\"2023-09-30\")","title":"Example 2: Loading a filing with a date"},{"location":"examples/","text":"Brel Examples This page contains examples of how to use Brel. Note: Brel does not contain any filings. You will have to download them yourself. You can find some example filings here . The following steps are required to download a filing and load it into Brel: Search for the filing on the SEC website. Under the \"10-K (Annual Report) and 10-Q (Quarterly Report)\" click on the \"Filing\" button. In the \"Data Files\" section, download all the \".xsd\" and \".xml\" files and place them in a folder (e.g. \"path/to/filing\"). Start python and import Brel. Load the filing using Filing.open(\"path/to/filing\") . Example 1: Loading a filing and printing its facts from brel import Filing, pprint # Load a filing from a file. In this case, the file is called \"filing.xml\". filing = Filing.from_file(\"path/to/filing.xml\") # Get all the facts in the filing. Take the first 10 facts. facts = filing.get_all_facts() first_10_facts = facts[:10] # Print the facts. pprint(first_10_facts) Example 2: Loading a filing and printing its facts where the concept is \"us-gaap:Assets\" from brel import Filing, pprint # Load a filing from a file. In this case, the file is called \"filing.xml\". filing = Filing.from_file(\"path/to/filing.xml\") # Get the concept \"us-gaap:Assets\". assets_concept = filing.get_concept(\"us-gaap:Assets\") # Get all the facts in the filing where the concept is \"us-gaap:Assets\". assets_facts = filing.get_facts_by_concept(assets_concept) # Print the facts. pprint(assets_facts) Example 3: Loading the cover page of a filing and printing its presentation network from brel import Filing, pprint # Load a filing from a file. In this case, the file is called \"filing.zip\". # Note that the zip file contains the filing's instance as well as its linkbases. filing = Filing.from_zip(\"path/to/filing.zip\") # Get the cover page component. cover_page_uri = \"http://www.mycompany.com/roles/coverpage\" cover_page_component = filing.get_component(cover_page_uri) if cover_page_component is None: raise Exception(f\"Could not find component with URI {cover_page_uri}\") # Get the presentation network of the cover page component and print it. presentation_network = cover_page_component.get_presentation_network() if presentation_network is not None: pprint(presentation_network) Additional Examples You can find additional examples in the \"examples\" folder of the repository . Make sure that in the examples, you replace the paths to the filings with the paths to your filings.","title":"Examples"},{"location":"examples/#brel-examples","text":"This page contains examples of how to use Brel. Note: Brel does not contain any filings. You will have to download them yourself. You can find some example filings here . The following steps are required to download a filing and load it into Brel: Search for the filing on the SEC website. Under the \"10-K (Annual Report) and 10-Q (Quarterly Report)\" click on the \"Filing\" button. In the \"Data Files\" section, download all the \".xsd\" and \".xml\" files and place them in a folder (e.g. \"path/to/filing\"). Start python and import Brel. Load the filing using Filing.open(\"path/to/filing\") .","title":"Brel Examples"},{"location":"examples/#example-1-loading-a-filing-and-printing-its-facts","text":"from brel import Filing, pprint # Load a filing from a file. In this case, the file is called \"filing.xml\". filing = Filing.from_file(\"path/to/filing.xml\") # Get all the facts in the filing. Take the first 10 facts. facts = filing.get_all_facts() first_10_facts = facts[:10] # Print the facts. pprint(first_10_facts)","title":"Example 1: Loading a filing and printing its facts"},{"location":"examples/#example-2-loading-a-filing-and-printing-its-facts-where-the-concept-is-us-gaapassets","text":"from brel import Filing, pprint # Load a filing from a file. In this case, the file is called \"filing.xml\". filing = Filing.from_file(\"path/to/filing.xml\") # Get the concept \"us-gaap:Assets\". assets_concept = filing.get_concept(\"us-gaap:Assets\") # Get all the facts in the filing where the concept is \"us-gaap:Assets\". assets_facts = filing.get_facts_by_concept(assets_concept) # Print the facts. pprint(assets_facts)","title":"Example 2: Loading a filing and printing its facts where the concept is \"us-gaap:Assets\""},{"location":"examples/#example-3-loading-the-cover-page-of-a-filing-and-printing-its-presentation-network","text":"from brel import Filing, pprint # Load a filing from a file. In this case, the file is called \"filing.zip\". # Note that the zip file contains the filing's instance as well as its linkbases. filing = Filing.from_zip(\"path/to/filing.zip\") # Get the cover page component. cover_page_uri = \"http://www.mycompany.com/roles/coverpage\" cover_page_component = filing.get_component(cover_page_uri) if cover_page_component is None: raise Exception(f\"Could not find component with URI {cover_page_uri}\") # Get the presentation network of the cover page component and print it. presentation_network = cover_page_component.get_presentation_network() if presentation_network is not None: pprint(presentation_network)","title":"Example 3: Loading the cover page of a filing and printing its presentation network"},{"location":"examples/#additional-examples","text":"You can find additional examples in the \"examples\" folder of the repository . Make sure that in the examples, you replace the paths to the filings with the paths to your filings.","title":"Additional Examples"},{"location":"brel-filings/filings/","text":"brel.brel_filing Brel operates on XBRL filings and represents them as a Filing object. This module contains the Filing class. Filings can be loaded from a folder, a zip file, or one or multiple xml files. If a folder is given, then all xml files in the folder are loaded. If a zip file is given, then the zip file is extracted to a folder and then all xml files in the folder are loaded. If one or more xml files are given, then only those xml files are loaded. A URI can also be given. In this case, the file is downloaded and cached in a folder. Note that Brel currently only supports XBRL filings in the form of XML files. Example usage: from brel import Filing # open apples 2023 Q3 10-Q filing filing1 = Filing.open(\"https://www.sec.gov/Archives/edgar/data/320193/000032019323000077/aapl-20230701_htm.xml\") filing2 = Filing.open(\"my_folder/\") filing3 = Filing.open(\"my_file.xml\", \"my_file2.xml\") # get the facts reporting against us-gaap:Assets assets_facts = filing1.get_facts_by_concept_name(\"us-gaap:Assets\") pprint_facts(assets_facts) Note that opening a filing can take a couple of seconds depending on the size of the filing. Once a filing is loaded, it can be queried for its facts, report elements, networks and components. ==================== author: Robin Schmidiger version: 0.5 date: 29 January 2024 ==================== Filing Objects class Filing() Represents an XBRL filing in the Open Information Model. open @classmethod def open(cls, path, *args) -> \"Filing\" Opens a Filing when given a path. The path can point to one of the following: a folder a zip file an xml file multiple xml files Notes: The args parameter is ignored unless the path points to an xml file. Depending on the size of the filing, loading can take a couple of seconds . Arguments : path : the path to the filing. This can be a folder, an xml file, or a zip file. args : additional xml files to load. These are only used if the path is an xml file. Raises : ValueError : if the path is not a valid path. Returns : Filing : a Filing object with the filing loaded. get_all_facts def get_all_facts() -> list[Fact] Returns : list[Fact] : a list of all Fact objects in the filing. get_all_report_elements def get_all_report_elements() -> list[IReportElement] Returns : list[IReportElement] : a list of all IReportElement objects in the filing. get_all_components def get_all_components() -> list[Component] Returns : list[Component] : a list of all Component objects in the filing. Note: components are sometimes called \"roles\" in the XBRL specification. get_all_physical_networks def get_all_physical_networks() -> list[INetwork] Get all INetwork objects in the filing, where network.is_physical() is True. Returns : list[INetwork] : a list of all physical networks in the filing. get_errors def get_errors() -> list[Exception] Returns : list[Exception] : a list of all errors that occurred during parsing. get_all_concepts def get_all_concepts() -> list[Concept] Returns : list[Concept] : a list of all concepts in the filing. Note that concepts are defined according to the Open Information Model. They are not the same as abstracts, line items, hypercubes, dimensions, or members. get_all_abstracts def get_all_abstracts() -> list[Abstract] Returns : list[Abstract] : a list of all abstracts in the filing. get_all_line_items def get_all_line_items() -> list[LineItems] Returns : list[LineItems] : a list of all line items in the filing. get_all_hypercubes def get_all_hypercubes() -> list[Hypercube] Returns : list[Hypercube] : a list of all hypercubes in the filing. get_all_dimensions def get_all_dimensions() -> list[Dimension] Returns : list[Dimension] : a list of all dimensions in the filing. get_all_members def get_all_members() -> list[Member] Returns : list[Member] : a list of all members in the filing. get_report_element_by_name def get_report_element_by_name( element_qname: QName | str) -> IReportElement | None Arguments : element_qname : the name of the report element to get. This can be a QName or a string in the format \"prefix:localname\". For example, \"us-gaap:Assets\". Raises : ValueError : if the QName string is not a valid QName or if the prefix is not found. Returns : IReportElement|None : the report element with the given name. If no report element is found, then None is returned. get_concept_by_name def get_concept_by_name(concept_qname: QName | str) -> Concept | None Arguments : concept_qname : the name of the concept to get. This can be a QName or a string in the format \"prefix:localname\". For example, \"us-gaap:Assets\". Raises : ValueError : if the QName string is not a valid QName or if the prefix is not found. Returns : Concept|None : the concept with the given name. If no concept is found, then None is returned. get_concept def get_concept(concept_qname: QName | str) -> Concept | None Alias of filing.get_concept_by_name(concept_qname) . get_all_reported_concepts def get_all_reported_concepts() -> list[Concept] Returns all concepts that have at least one fact reporting against them. Returns : list[Concept] : The list of concepts get_facts_by_concept_name def get_facts_by_concept_name(concept_name: QName | str) -> list[Fact] Returns all facts that are associated with the concept with name concept_name. Arguments : concept_name : The name of the concept to get facts for. This can be a QName or a string in the format \"prefix:localname\". For example, \"us-gaap:Assets\". Raises : ValueError : if the QName string but is not a valid QName or if the prefix is not found. Returns : list[Fact] : the list of facts get_facts_by_concept def get_facts_by_concept(concept: Concept) -> list[Fact] Returns all facts that are associated with a concept. Arguments : concept : the concept to get facts for. Returns : list[Fact] : the list of facts get_all_component_uris def get_all_component_uris() -> list[str] Returns : list[str] : a list of all component URIs in the filing. get_component def get_component(uri: str) -> Component | None Arguments : URI : the URI of the component to get. Returns : Component|None : the component with the given URI. None if no component is found.","title":"Filings"},{"location":"brel-filings/filings/#brelbrel_filing","text":"Brel operates on XBRL filings and represents them as a Filing object. This module contains the Filing class. Filings can be loaded from a folder, a zip file, or one or multiple xml files. If a folder is given, then all xml files in the folder are loaded. If a zip file is given, then the zip file is extracted to a folder and then all xml files in the folder are loaded. If one or more xml files are given, then only those xml files are loaded. A URI can also be given. In this case, the file is downloaded and cached in a folder. Note that Brel currently only supports XBRL filings in the form of XML files. Example usage: from brel import Filing # open apples 2023 Q3 10-Q filing filing1 = Filing.open(\"https://www.sec.gov/Archives/edgar/data/320193/000032019323000077/aapl-20230701_htm.xml\") filing2 = Filing.open(\"my_folder/\") filing3 = Filing.open(\"my_file.xml\", \"my_file2.xml\") # get the facts reporting against us-gaap:Assets assets_facts = filing1.get_facts_by_concept_name(\"us-gaap:Assets\") pprint_facts(assets_facts) Note that opening a filing can take a couple of seconds depending on the size of the filing. Once a filing is loaded, it can be queried for its facts, report elements, networks and components. ==================== author: Robin Schmidiger version: 0.5 date: 29 January 2024 ====================","title":"brel.brel_filing"},{"location":"brel-filings/filings/#filing-objects","text":"class Filing() Represents an XBRL filing in the Open Information Model.","title":"Filing Objects"},{"location":"brel-filings/filings/#open","text":"@classmethod def open(cls, path, *args) -> \"Filing\" Opens a Filing when given a path. The path can point to one of the following: a folder a zip file an xml file multiple xml files Notes: The args parameter is ignored unless the path points to an xml file. Depending on the size of the filing, loading can take a couple of seconds . Arguments : path : the path to the filing. This can be a folder, an xml file, or a zip file. args : additional xml files to load. These are only used if the path is an xml file. Raises : ValueError : if the path is not a valid path. Returns : Filing : a Filing object with the filing loaded.","title":"open"},{"location":"brel-filings/filings/#get_all_facts","text":"def get_all_facts() -> list[Fact] Returns : list[Fact] : a list of all Fact objects in the filing.","title":"get_all_facts"},{"location":"brel-filings/filings/#get_all_report_elements","text":"def get_all_report_elements() -> list[IReportElement] Returns : list[IReportElement] : a list of all IReportElement objects in the filing.","title":"get_all_report_elements"},{"location":"brel-filings/filings/#get_all_components","text":"def get_all_components() -> list[Component] Returns : list[Component] : a list of all Component objects in the filing. Note: components are sometimes called \"roles\" in the XBRL specification.","title":"get_all_components"},{"location":"brel-filings/filings/#get_all_physical_networks","text":"def get_all_physical_networks() -> list[INetwork] Get all INetwork objects in the filing, where network.is_physical() is True. Returns : list[INetwork] : a list of all physical networks in the filing.","title":"get_all_physical_networks"},{"location":"brel-filings/filings/#get_errors","text":"def get_errors() -> list[Exception] Returns : list[Exception] : a list of all errors that occurred during parsing.","title":"get_errors"},{"location":"brel-filings/filings/#get_all_concepts","text":"def get_all_concepts() -> list[Concept] Returns : list[Concept] : a list of all concepts in the filing. Note that concepts are defined according to the Open Information Model. They are not the same as abstracts, line items, hypercubes, dimensions, or members.","title":"get_all_concepts"},{"location":"brel-filings/filings/#get_all_abstracts","text":"def get_all_abstracts() -> list[Abstract] Returns : list[Abstract] : a list of all abstracts in the filing.","title":"get_all_abstracts"},{"location":"brel-filings/filings/#get_all_line_items","text":"def get_all_line_items() -> list[LineItems] Returns : list[LineItems] : a list of all line items in the filing.","title":"get_all_line_items"},{"location":"brel-filings/filings/#get_all_hypercubes","text":"def get_all_hypercubes() -> list[Hypercube] Returns : list[Hypercube] : a list of all hypercubes in the filing.","title":"get_all_hypercubes"},{"location":"brel-filings/filings/#get_all_dimensions","text":"def get_all_dimensions() -> list[Dimension] Returns : list[Dimension] : a list of all dimensions in the filing.","title":"get_all_dimensions"},{"location":"brel-filings/filings/#get_all_members","text":"def get_all_members() -> list[Member] Returns : list[Member] : a list of all members in the filing.","title":"get_all_members"},{"location":"brel-filings/filings/#get_report_element_by_name","text":"def get_report_element_by_name( element_qname: QName | str) -> IReportElement | None Arguments : element_qname : the name of the report element to get. This can be a QName or a string in the format \"prefix:localname\". For example, \"us-gaap:Assets\". Raises : ValueError : if the QName string is not a valid QName or if the prefix is not found. Returns : IReportElement|None : the report element with the given name. If no report element is found, then None is returned.","title":"get_report_element_by_name"},{"location":"brel-filings/filings/#get_concept_by_name","text":"def get_concept_by_name(concept_qname: QName | str) -> Concept | None Arguments : concept_qname : the name of the concept to get. This can be a QName or a string in the format \"prefix:localname\". For example, \"us-gaap:Assets\". Raises : ValueError : if the QName string is not a valid QName or if the prefix is not found. Returns : Concept|None : the concept with the given name. If no concept is found, then None is returned.","title":"get_concept_by_name"},{"location":"brel-filings/filings/#get_concept","text":"def get_concept(concept_qname: QName | str) -> Concept | None Alias of filing.get_concept_by_name(concept_qname) .","title":"get_concept"},{"location":"brel-filings/filings/#get_all_reported_concepts","text":"def get_all_reported_concepts() -> list[Concept] Returns all concepts that have at least one fact reporting against them. Returns : list[Concept] : The list of concepts","title":"get_all_reported_concepts"},{"location":"brel-filings/filings/#get_facts_by_concept_name","text":"def get_facts_by_concept_name(concept_name: QName | str) -> list[Fact] Returns all facts that are associated with the concept with name concept_name. Arguments : concept_name : The name of the concept to get facts for. This can be a QName or a string in the format \"prefix:localname\". For example, \"us-gaap:Assets\". Raises : ValueError : if the QName string but is not a valid QName or if the prefix is not found. Returns : list[Fact] : the list of facts","title":"get_facts_by_concept_name"},{"location":"brel-filings/filings/#get_facts_by_concept","text":"def get_facts_by_concept(concept: Concept) -> list[Fact] Returns all facts that are associated with a concept. Arguments : concept : the concept to get facts for. Returns : list[Fact] : the list of facts","title":"get_facts_by_concept"},{"location":"brel-filings/filings/#get_all_component_uris","text":"def get_all_component_uris() -> list[str] Returns : list[str] : a list of all component URIs in the filing.","title":"get_all_component_uris"},{"location":"brel-filings/filings/#get_component","text":"def get_component(uri: str) -> Component | None Arguments : URI : the URI of the component to get. Returns : Component|None : the component with the given URI. None if no component is found.","title":"get_component"},{"location":"components/calculation-networks-and-nodes/","text":"brel.networks.calculation_network_node This module contains the CalculationNetworkNode class. CalculationNetworkNodes are used to represent nodes in a calculation network. Since a node can have children, nodes can also be viewed as trees. Note: the balance consistency check is not implemented here, but in the CalculationNetwork class. CalculationNetworkNodes implement the INetworkNode interface, but they add the methods get_concept() and get_weight() . Note that this documentation omits the methods inherited from the INetworkNode interface. For more on the methods inherited from the INetworkNode interface, see the INetworkNode documentation . ================= author: Robin Schmidiger version: 0.9 date: 30 December 2023 ================= CalculationNetworkNode Objects class CalculationNetworkNode(INetworkNode) Class for representing a node in a network. Since a node can have children, nodes can also be viewed as trees. get_report_element def get_report_element() -> IReportElement Returns : IReportElement : report element associated with this node. Use the points_to() method to check if this node points to a report element. get_resource def get_resource() -> IResource Would return the resource associated with this node, but calculation network nodes do not point to resources Raises : ValueError : CalculationNetworkNode does not point to a resource get_fact def get_fact() -> Fact Would return the fact associated with this node, but calculation network nodes do not point to facts Raises : ValueError : CalculationNetworkNode does not point to a fact points_to def points_to() -> str Returns : str : returns 'report element' get_weight def get_weight() -> float Returns : float : Returns the weight of this node get_concept def get_concept() -> Concept CalculationNetworkNodes are only associated with concepts Returns : Concept : The concept associated with this node brel.networks.calculation_network This module contains the class for representing a calculation network. A calculation network is a network of nodes that represent the calculation of a Component. Calculation networks also contain helper functions for checking the consistency of the calculation network specifically. ==================== author: Robin Schmidiger version: 0.3 date: 29 December 2023 ==================== CalculationNetwork Objects class CalculationNetwork(INetwork) The class for representing a calculation network. A calculation network is a network of nodes that indicate which concepts are calculated from which other concepts. is_balance_consisent def is_balance_consisent() -> bool Returns true if the network is balance consistent. A network is balance consistent iff, for each parent-child relationship - if the two concepts have the same balance (credit/credit or debit/debit), then the child weight must be positive - if the two concepts have different balances (credit/debit or debit/credit), then the child weight must be negative Returns : bool : True iff the network is balance consistent is_aggregation_consistent def is_aggregation_consistent(facts: list[Fact]) -> bool A calculation network is aggregation consistent iff for concepts of nodes, the sum of the fact values of the children equals the fact value of the parent. If there are multiple facts for a concept, but the facts have different dates, then aggregation consistency is checked for each date separately. This not only holds for the date aspect, but for all aspects of the fact. Arguments : facts : the facts of the filing against which to check the aggregation consistency Returns : bool : True iff the network is aggregation consistent","title":"Calculation Networks and Nodes"},{"location":"components/calculation-networks-and-nodes/#brelnetworkscalculation_network_node","text":"This module contains the CalculationNetworkNode class. CalculationNetworkNodes are used to represent nodes in a calculation network. Since a node can have children, nodes can also be viewed as trees. Note: the balance consistency check is not implemented here, but in the CalculationNetwork class. CalculationNetworkNodes implement the INetworkNode interface, but they add the methods get_concept() and get_weight() . Note that this documentation omits the methods inherited from the INetworkNode interface. For more on the methods inherited from the INetworkNode interface, see the INetworkNode documentation . ================= author: Robin Schmidiger version: 0.9 date: 30 December 2023 =================","title":"brel.networks.calculation_network_node"},{"location":"components/calculation-networks-and-nodes/#calculationnetworknode-objects","text":"class CalculationNetworkNode(INetworkNode) Class for representing a node in a network. Since a node can have children, nodes can also be viewed as trees.","title":"CalculationNetworkNode Objects"},{"location":"components/calculation-networks-and-nodes/#get_report_element","text":"def get_report_element() -> IReportElement Returns : IReportElement : report element associated with this node. Use the points_to() method to check if this node points to a report element.","title":"get_report_element"},{"location":"components/calculation-networks-and-nodes/#get_resource","text":"def get_resource() -> IResource Would return the resource associated with this node, but calculation network nodes do not point to resources Raises : ValueError : CalculationNetworkNode does not point to a resource","title":"get_resource"},{"location":"components/calculation-networks-and-nodes/#get_fact","text":"def get_fact() -> Fact Would return the fact associated with this node, but calculation network nodes do not point to facts Raises : ValueError : CalculationNetworkNode does not point to a fact","title":"get_fact"},{"location":"components/calculation-networks-and-nodes/#points_to","text":"def points_to() -> str Returns : str : returns 'report element'","title":"points_to"},{"location":"components/calculation-networks-and-nodes/#get_weight","text":"def get_weight() -> float Returns : float : Returns the weight of this node","title":"get_weight"},{"location":"components/calculation-networks-and-nodes/#get_concept","text":"def get_concept() -> Concept CalculationNetworkNodes are only associated with concepts Returns : Concept : The concept associated with this node","title":"get_concept"},{"location":"components/calculation-networks-and-nodes/#brelnetworkscalculation_network","text":"This module contains the class for representing a calculation network. A calculation network is a network of nodes that represent the calculation of a Component. Calculation networks also contain helper functions for checking the consistency of the calculation network specifically. ==================== author: Robin Schmidiger version: 0.3 date: 29 December 2023 ====================","title":"brel.networks.calculation_network"},{"location":"components/calculation-networks-and-nodes/#calculationnetwork-objects","text":"class CalculationNetwork(INetwork) The class for representing a calculation network. A calculation network is a network of nodes that indicate which concepts are calculated from which other concepts.","title":"CalculationNetwork Objects"},{"location":"components/calculation-networks-and-nodes/#is_balance_consisent","text":"def is_balance_consisent() -> bool Returns true if the network is balance consistent. A network is balance consistent iff, for each parent-child relationship - if the two concepts have the same balance (credit/credit or debit/debit), then the child weight must be positive - if the two concepts have different balances (credit/debit or debit/credit), then the child weight must be negative Returns : bool : True iff the network is balance consistent","title":"is_balance_consisent"},{"location":"components/calculation-networks-and-nodes/#is_aggregation_consistent","text":"def is_aggregation_consistent(facts: list[Fact]) -> bool A calculation network is aggregation consistent iff for concepts of nodes, the sum of the fact values of the children equals the fact value of the parent. If there are multiple facts for a concept, but the facts have different dates, then aggregation consistency is checked for each date separately. This not only holds for the date aspect, but for all aspects of the fact. Arguments : facts : the facts of the filing against which to check the aggregation consistency Returns : bool : True iff the network is aggregation consistent","title":"is_aggregation_consistent"},{"location":"components/components/","text":"brel.brel_component This module contains the Component class. Components are used to define the presentation, calculation and definition networks of a filing. Intuitively, they function as the chapters of a report or filing. Note that XBRL sometimes calls components 'roles'. Given a report, you can get all the components using the Filing.get_all_components() method. If you are looking for a specific component, consider the following: all_component_URIs = filing.get_all_component_URIs() # select one of the component names from the list my_component_name = all_component_URIs[0] # get the component my_component = filing.get_component(my_component_name) Components act as wrappers for the Network s of a filing. The most notable kind of networks are the presentation, calculation and definition networks. get the PresentationNetwork using the Component.get_presentation_network() method. get the CalculationNetwork using the Component.get_calculation_network() method. get the DefinitionNetwork using the Component.get_definition_network() method. You can print them using the pprint_network function in the brel module: from brel import pprint calculation_network = my_component.get_calculation_network() pprint(calculation_network) ==================== author: Robin Schmidiger version: 0.7 date: 30 January 2024 ==================== Component Objects class Component() This class implements XBRL components, which are sometimes also called roles. Components are used to define the presentation, calculation and definition networks of a filing. Intuitively, they function as the chapters of a report or filing. A component consists of the following: a URI, also called the roleURI. This is the identifier of the component. an info, also called the definition. This is a string that describes the component. It is optional. a set of networks. The most notable kind of networks are the presentation, calculation and definition networks. get_URI def get_URI() -> str Returns : str : the URI of the component get_info def get_info() -> str Returns : str : the info/definition of the component. get_presentation_network def get_presentation_network() -> PresentationNetwork | None Returns : PresentationNetwork : the presentation network of the component. None if the component has no presentation network or if the network is empty. get_calculation_network def get_calculation_network() -> CalculationNetwork | None Returns : CalculationNetwork : the calculation network of the component. None if the component has no calculation network or if the network is empty. get_definition_network def get_definition_network() -> DefinitionNetwork | None Returns : DefinitionNetwork : the definition network of the component. None if the component has no definition network or if the network is empty. has_presentation_network def has_presentation_network() -> bool Returns : bool : True if the component has a presentation network, False otherwise has_calculation_network def has_calculation_network() -> bool Returns : bool : True if the component has a calculation network, False otherwise has_definition_network def has_definition_network() -> bool Returns : bool : True if the component has a definition network, False otherwise __str__ def __str__() -> str Returns : str : a string representation of the component is_aggregation_consistent def is_aggregation_consistent(facts: list[Fact]) -> bool Arguments : facts : the facts of the filing Returns : bool : True if and only if the component is aggregation consistent against the given facts get_networks def get_networks() -> list[INetwork] Returns : list[INetwork] : the networks of the component","title":"Components"},{"location":"components/components/#brelbrel_component","text":"This module contains the Component class. Components are used to define the presentation, calculation and definition networks of a filing. Intuitively, they function as the chapters of a report or filing. Note that XBRL sometimes calls components 'roles'. Given a report, you can get all the components using the Filing.get_all_components() method. If you are looking for a specific component, consider the following: all_component_URIs = filing.get_all_component_URIs() # select one of the component names from the list my_component_name = all_component_URIs[0] # get the component my_component = filing.get_component(my_component_name) Components act as wrappers for the Network s of a filing. The most notable kind of networks are the presentation, calculation and definition networks. get the PresentationNetwork using the Component.get_presentation_network() method. get the CalculationNetwork using the Component.get_calculation_network() method. get the DefinitionNetwork using the Component.get_definition_network() method. You can print them using the pprint_network function in the brel module: from brel import pprint calculation_network = my_component.get_calculation_network() pprint(calculation_network) ==================== author: Robin Schmidiger version: 0.7 date: 30 January 2024 ====================","title":"brel.brel_component"},{"location":"components/components/#component-objects","text":"class Component() This class implements XBRL components, which are sometimes also called roles. Components are used to define the presentation, calculation and definition networks of a filing. Intuitively, they function as the chapters of a report or filing. A component consists of the following: a URI, also called the roleURI. This is the identifier of the component. an info, also called the definition. This is a string that describes the component. It is optional. a set of networks. The most notable kind of networks are the presentation, calculation and definition networks.","title":"Component Objects"},{"location":"components/components/#get_uri","text":"def get_URI() -> str Returns : str : the URI of the component","title":"get_URI"},{"location":"components/components/#get_info","text":"def get_info() -> str Returns : str : the info/definition of the component.","title":"get_info"},{"location":"components/components/#get_presentation_network","text":"def get_presentation_network() -> PresentationNetwork | None Returns : PresentationNetwork : the presentation network of the component. None if the component has no presentation network or if the network is empty.","title":"get_presentation_network"},{"location":"components/components/#get_calculation_network","text":"def get_calculation_network() -> CalculationNetwork | None Returns : CalculationNetwork : the calculation network of the component. None if the component has no calculation network or if the network is empty.","title":"get_calculation_network"},{"location":"components/components/#get_definition_network","text":"def get_definition_network() -> DefinitionNetwork | None Returns : DefinitionNetwork : the definition network of the component. None if the component has no definition network or if the network is empty.","title":"get_definition_network"},{"location":"components/components/#has_presentation_network","text":"def has_presentation_network() -> bool Returns : bool : True if the component has a presentation network, False otherwise","title":"has_presentation_network"},{"location":"components/components/#has_calculation_network","text":"def has_calculation_network() -> bool Returns : bool : True if the component has a calculation network, False otherwise","title":"has_calculation_network"},{"location":"components/components/#has_definition_network","text":"def has_definition_network() -> bool Returns : bool : True if the component has a definition network, False otherwise","title":"has_definition_network"},{"location":"components/components/#__str__","text":"def __str__() -> str Returns : str : a string representation of the component","title":"__str__"},{"location":"components/components/#is_aggregation_consistent","text":"def is_aggregation_consistent(facts: list[Fact]) -> bool Arguments : facts : the facts of the filing Returns : bool : True if and only if the component is aggregation consistent against the given facts","title":"is_aggregation_consistent"},{"location":"components/components/#get_networks","text":"def get_networks() -> list[INetwork] Returns : list[INetwork] : the networks of the component","title":"get_networks"},{"location":"components/network-nodes/","text":"brel.networks.i_network_node This module contains the interface for a node in a network. All nodes in a network are built on a common interface that allows for some basic navigation of the network. The network node interface also contains some utility methods for working with networks and nodes. ==================== author: Robin Schmidiger version: 0.3 date: 2023-12-29 ==================== INetworkNode Objects class INetworkNode(ABC) Interface for representing a node in a network. Since a node can have children, nodes can also be viewed as trees. Each node in a network can point to one of the following: A report element IReportElement : use node.get_report_element() A resource IResource : use node.get_resource() A fact Fact : The getter methods above will raise a ValueError if the node does not point to the requested type. Use the points_to() method to check if the node points to a report element, resource or fact. If the node points to a report element, points_to() will return 'report element' If the node points to a resource, points_to() will return 'resource' If the node points to a fact, points_to() will return 'fact' To navigate the network, use the get_children() method to get the children of a node. Each node also has an order attribute which can be accessed using the get_order() method. The children of a node are ordered by their order attribute. get_report_element @abstractmethod def get_report_element() -> IReportElement Raises : ValueError : if this node does not point to a report element. Use the points_to() method to check if this node points to a report element. Returns : IReportElement : report element associated with this node. get_resource @abstractmethod def get_resource() -> IResource Raises : ValueError : if this node does not point to a resource. Use the points_to() method to check if this node points to a resource. Returns : IResource : resource associated with this node. get_fact @abstractmethod def get_fact() -> Fact Raises : ValueError : if this node does not point to a fact. Use the points_to() method to check if this node points to a fact. Returns : Fact : fact associated with this node. points_to @abstractmethod def points_to() -> str Returns 'resource' if this node points to a resource 'report element' if this node points to a report element 'fact' if this node points to a fact Returns : str : containing 'resource', 'report element' or 'fact' get_children @abstractmethod def get_children() -> list[\"INetworkNode\"] Returns all children of this node Returns : list[NetworkNode] : list containing the children of this node get_arc_role @abstractmethod def get_arc_role() -> str Returns : str : the arc role of this node. There can be nodes with different arc roles in the same network. get_arc_name @abstractmethod def get_arc_name() -> QName Returns : QName : the arc name of this node. All nodes in the same network have the same arc name. get_link_role @abstractmethod def get_link_role() -> str Returns : str : the link role of this node. This is the same as the link role of the network that the node is in. get_link_name @abstractmethod def get_link_name() -> QName Returns : QName : the link name of this node. This is the same as the link name of the network that the node is in. get_all_descendants def get_all_descendants() -> list[\"INetworkNode\"] Returns all descendants of the current node Returns : list[NetworkNode] : list containing all descendants of this node is_leaf def is_leaf() -> bool Returns : bool : True if this node is a leaf, False otherwise get_order @abstractmethod def get_order() -> float Returns : float : The order of this node. Nodes are ordered by their order attribute.","title":"Network Nodes"},{"location":"components/network-nodes/#brelnetworksi_network_node","text":"This module contains the interface for a node in a network. All nodes in a network are built on a common interface that allows for some basic navigation of the network. The network node interface also contains some utility methods for working with networks and nodes. ==================== author: Robin Schmidiger version: 0.3 date: 2023-12-29 ====================","title":"brel.networks.i_network_node"},{"location":"components/network-nodes/#inetworknode-objects","text":"class INetworkNode(ABC) Interface for representing a node in a network. Since a node can have children, nodes can also be viewed as trees. Each node in a network can point to one of the following: A report element IReportElement : use node.get_report_element() A resource IResource : use node.get_resource() A fact Fact : The getter methods above will raise a ValueError if the node does not point to the requested type. Use the points_to() method to check if the node points to a report element, resource or fact. If the node points to a report element, points_to() will return 'report element' If the node points to a resource, points_to() will return 'resource' If the node points to a fact, points_to() will return 'fact' To navigate the network, use the get_children() method to get the children of a node. Each node also has an order attribute which can be accessed using the get_order() method. The children of a node are ordered by their order attribute.","title":"INetworkNode Objects"},{"location":"components/network-nodes/#get_report_element","text":"@abstractmethod def get_report_element() -> IReportElement Raises : ValueError : if this node does not point to a report element. Use the points_to() method to check if this node points to a report element. Returns : IReportElement : report element associated with this node.","title":"get_report_element"},{"location":"components/network-nodes/#get_resource","text":"@abstractmethod def get_resource() -> IResource Raises : ValueError : if this node does not point to a resource. Use the points_to() method to check if this node points to a resource. Returns : IResource : resource associated with this node.","title":"get_resource"},{"location":"components/network-nodes/#get_fact","text":"@abstractmethod def get_fact() -> Fact Raises : ValueError : if this node does not point to a fact. Use the points_to() method to check if this node points to a fact. Returns : Fact : fact associated with this node.","title":"get_fact"},{"location":"components/network-nodes/#points_to","text":"@abstractmethod def points_to() -> str Returns 'resource' if this node points to a resource 'report element' if this node points to a report element 'fact' if this node points to a fact Returns : str : containing 'resource', 'report element' or 'fact'","title":"points_to"},{"location":"components/network-nodes/#get_children","text":"@abstractmethod def get_children() -> list[\"INetworkNode\"] Returns all children of this node Returns : list[NetworkNode] : list containing the children of this node","title":"get_children"},{"location":"components/network-nodes/#get_arc_role","text":"@abstractmethod def get_arc_role() -> str Returns : str : the arc role of this node. There can be nodes with different arc roles in the same network.","title":"get_arc_role"},{"location":"components/network-nodes/#get_arc_name","text":"@abstractmethod def get_arc_name() -> QName Returns : QName : the arc name of this node. All nodes in the same network have the same arc name.","title":"get_arc_name"},{"location":"components/network-nodes/#get_link_role","text":"@abstractmethod def get_link_role() -> str Returns : str : the link role of this node. This is the same as the link role of the network that the node is in.","title":"get_link_role"},{"location":"components/network-nodes/#get_link_name","text":"@abstractmethod def get_link_name() -> QName Returns : QName : the link name of this node. This is the same as the link name of the network that the node is in.","title":"get_link_name"},{"location":"components/network-nodes/#get_all_descendants","text":"def get_all_descendants() -> list[\"INetworkNode\"] Returns all descendants of the current node Returns : list[NetworkNode] : list containing all descendants of this node","title":"get_all_descendants"},{"location":"components/network-nodes/#is_leaf","text":"def is_leaf() -> bool Returns : bool : True if this node is a leaf, False otherwise","title":"is_leaf"},{"location":"components/network-nodes/#get_order","text":"@abstractmethod def get_order() -> float Returns : float : The order of this node. Nodes are ordered by their order attribute.","title":"get_order"},{"location":"components/networks/","text":"brel.networks.i_network Networks in XBRL are used to define relationships between different things in a filing. For example Presentation networks define a hierarchy of report elements Calculation networks define which concepts should be the sum of which other concepts Definition networks define what the relationship between the types of the report elements are Label networks establish relationships between report elements and human readable labels Reference networks establish a link between report elements and other resources such as websites or documents All networks in brel are represented by the INetwork interface. Since only the calculation network has any special functionality thus far, the other networks are not part of this documentation. They are all implemented in the same way as the calculation network and can be inspected using their shared interface INetwork. ==================== author: Robin Schmidiger version: 0.6 date: 07 January 2024 ==================== INetwork Objects class INetwork(ABC) Interface for representing networks in Brel. The networks are defined according to the XBRL Generic Links 1.0 specification available HERE get_roots def get_roots() -> list[INetworkNode] Get all root nodes of the network Returns : list[NetworkNode] : representing the root nodes of the network. get_link_role def get_link_role() -> str Get the link role of the network Returns : str : containing the link role of the network. Note: This returns the same as get_URL() on the parent component get_link_name def get_link_name() -> QName Get the link name of the network Returns : QName : link name of the network. e.g. for presentation networks this is usually \"link:presentationLink\" is_physical def is_physical() -> bool Check if the network is a physical network Physical networks must have the same link/arc role/name across all nodes Returns : bool : indicating if the network is a physical network get_arc_roles def get_arc_roles() -> list[str] Get all the arc roles that are used by nodes in the network Returns : list[str] : list of all arc roles that are used by nodes in the network get_arc_name def get_arc_name() -> QName | None Get the arc name of all the arcs in the network. All arcs in the network have the same arc name. Returns : QName|None : The arc name of all the arcs in the network. Returns None if the network is empty. get_root def get_root() -> INetworkNode Get the root node of the network if the network has only one root. Note that each network must have at least one root node. Raises : ValueError : if the network has multiple roots Returns : NetworkNode : representing the root node of the network. get_all_nodes def get_all_nodes() -> list[INetworkNode] Get all nodes in the network as a list Returns : list[NetworkNode] : containing all nodes in the network","title":"Networks"},{"location":"components/networks/#brelnetworksi_network","text":"Networks in XBRL are used to define relationships between different things in a filing. For example Presentation networks define a hierarchy of report elements Calculation networks define which concepts should be the sum of which other concepts Definition networks define what the relationship between the types of the report elements are Label networks establish relationships between report elements and human readable labels Reference networks establish a link between report elements and other resources such as websites or documents All networks in brel are represented by the INetwork interface. Since only the calculation network has any special functionality thus far, the other networks are not part of this documentation. They are all implemented in the same way as the calculation network and can be inspected using their shared interface INetwork. ==================== author: Robin Schmidiger version: 0.6 date: 07 January 2024 ====================","title":"brel.networks.i_network"},{"location":"components/networks/#inetwork-objects","text":"class INetwork(ABC) Interface for representing networks in Brel. The networks are defined according to the XBRL Generic Links 1.0 specification available HERE","title":"INetwork Objects"},{"location":"components/networks/#get_roots","text":"def get_roots() -> list[INetworkNode] Get all root nodes of the network Returns : list[NetworkNode] : representing the root nodes of the network.","title":"get_roots"},{"location":"components/networks/#get_link_role","text":"def get_link_role() -> str Get the link role of the network Returns : str : containing the link role of the network. Note: This returns the same as get_URL() on the parent component","title":"get_link_role"},{"location":"components/networks/#get_link_name","text":"def get_link_name() -> QName Get the link name of the network Returns : QName : link name of the network. e.g. for presentation networks this is usually \"link:presentationLink\"","title":"get_link_name"},{"location":"components/networks/#is_physical","text":"def is_physical() -> bool Check if the network is a physical network Physical networks must have the same link/arc role/name across all nodes Returns : bool : indicating if the network is a physical network","title":"is_physical"},{"location":"components/networks/#get_arc_roles","text":"def get_arc_roles() -> list[str] Get all the arc roles that are used by nodes in the network Returns : list[str] : list of all arc roles that are used by nodes in the network","title":"get_arc_roles"},{"location":"components/networks/#get_arc_name","text":"def get_arc_name() -> QName | None Get the arc name of all the arcs in the network. All arcs in the network have the same arc name. Returns : QName|None : The arc name of all the arcs in the network. Returns None if the network is empty.","title":"get_arc_name"},{"location":"components/networks/#get_root","text":"def get_root() -> INetworkNode Get the root node of the network if the network has only one root. Note that each network must have at least one root node. Raises : ValueError : if the network has multiple roots Returns : NetworkNode : representing the root node of the network.","title":"get_root"},{"location":"components/networks/#get_all_nodes","text":"def get_all_nodes() -> list[INetworkNode] Get all nodes in the network as a list Returns : list[NetworkNode] : containing all nodes in the network","title":"get_all_nodes"},{"location":"facts/aspects/","text":"brel.characteristics.brel_aspect This module contains the Aspect class. Aspects are the building blocks of the Context of a fact. They are split into two categories: core aspects and custom aspects. Core aspects are the 5 base aspects: concept, period, entity and unit. Custom aspects are all other aspects that are not core aspects. ==================== author: Robin Schmidiger version: 0.2 date: 08 January 2024 ==================== Aspect Objects class Aspect() Base class for all aspects. An an aspect is a wrapper around a string-id. This string-id is called the name of the aspect. An aspect can also have human readable labels for its name. The four core aspects are instances of this class and are accessible as class attributes. These four core aspects are available as the following class attributes: Aspect.CONCEPT Aspect.PERIOD Aspect.ENTITY Aspect.UNIT A lot of reports omit the language aspect, but it can be emulated by using a custom aspect. All but the concept aspect are optional for a context. get_name def get_name() -> str Get the name of the aspect. is_core def is_core() -> bool Check if the aspect is a core aspect. get_labels def get_labels() -> list[BrelLabel] Get the labels of the aspect. from_QName @classmethod def from_QName(cls, qname: QName, labels: list[BrelLabel] | None = None) -> \"Aspect\" Creates a new aspect from a QName. The method get_name() of the newly created aspect will return the string generated by qname.get() . Arguments : qname : the QName to create the aspect from labels : A list of labels for the aspect. If None, an empty list is used. from_str @classmethod def from_str(cls, name: str, labels: list[BrelLabel] | None = None) -> \"Aspect\" Creates a new aspect from a string. To access the core aspects, use the class attributes Aspect.CONCEPT , Aspect.PERIOD , Aspect.ENTITY and Aspect.UNIT instead. Arguments : name : The name of the aspect labels : A list of labels for the aspect. If None, an empty list is used.","title":"Aspects"},{"location":"facts/aspects/#brelcharacteristicsbrel_aspect","text":"This module contains the Aspect class. Aspects are the building blocks of the Context of a fact. They are split into two categories: core aspects and custom aspects. Core aspects are the 5 base aspects: concept, period, entity and unit. Custom aspects are all other aspects that are not core aspects. ==================== author: Robin Schmidiger version: 0.2 date: 08 January 2024 ====================","title":"brel.characteristics.brel_aspect"},{"location":"facts/aspects/#aspect-objects","text":"class Aspect() Base class for all aspects. An an aspect is a wrapper around a string-id. This string-id is called the name of the aspect. An aspect can also have human readable labels for its name. The four core aspects are instances of this class and are accessible as class attributes. These four core aspects are available as the following class attributes: Aspect.CONCEPT Aspect.PERIOD Aspect.ENTITY Aspect.UNIT A lot of reports omit the language aspect, but it can be emulated by using a custom aspect. All but the concept aspect are optional for a context.","title":"Aspect Objects"},{"location":"facts/aspects/#get_name","text":"def get_name() -> str Get the name of the aspect.","title":"get_name"},{"location":"facts/aspects/#is_core","text":"def is_core() -> bool Check if the aspect is a core aspect.","title":"is_core"},{"location":"facts/aspects/#get_labels","text":"def get_labels() -> list[BrelLabel] Get the labels of the aspect.","title":"get_labels"},{"location":"facts/aspects/#from_qname","text":"@classmethod def from_QName(cls, qname: QName, labels: list[BrelLabel] | None = None) -> \"Aspect\" Creates a new aspect from a QName. The method get_name() of the newly created aspect will return the string generated by qname.get() . Arguments : qname : the QName to create the aspect from labels : A list of labels for the aspect. If None, an empty list is used.","title":"from_QName"},{"location":"facts/aspects/#from_str","text":"@classmethod def from_str(cls, name: str, labels: list[BrelLabel] | None = None) -> \"Aspect\" Creates a new aspect from a string. To access the core aspects, use the class attributes Aspect.CONCEPT , Aspect.PERIOD , Aspect.ENTITY and Aspect.UNIT instead. Arguments : name : The name of the aspect labels : A list of labels for the aspect. If None, an empty list is used.","title":"from_str"},{"location":"facts/characteristics/","text":"brel.characteristics.i_characteristic This module contains the interface for a characteristic. Characteristics are what makes up the context of a fact. They are a binding between an aspect and a value. There are characteristics for the 5 core aspects. ConceptCharacteristic for Aspect.CONCEPT PeriodCharacteristic for Aspect.PERIOD EntityCharacteristic for Aspect.ENTITY UnitCharacteristic for Aspect.UNIT There are also characteristics for custom aspects. Custom aspects can either be typed or explicit. A explicit aspect is an aspect where the characteristic value is one option from a list of options. For example, consider the following facts: The Foo Company has a revenue of 1000 USD in 2020 in the region North America. The Foo Company has a revenue of 2000 USD in 2020 in the region Europe. The region aspect is an explicit aspect since the options that the region aspect can take are limited to North America and Europe. A typed aspect is an aspect where the characteristic value is a value of a certain type. Brel simplifies this by making the value a string and the type a QName. For example, consider the following facts: The Bar Company has 8 employees that earn 1000 USD per month in 2020. The Bar Company has 2 employees that earn 2000 USD per month in 2020. In this case value of the fact is the number of employees. The type aspect is the 'salary per month' aspect, is an integer. ExplicitDimensionCharacteristic for explicit dimensions. TypedDimensionCharacteristic for typed dimensions. ================= author: Robin Schmidiger version: 0.1 date: 2023-12-06 ================= ICharacteristic Objects class ICharacteristic(ABC) The Interface for a characteristic. A characteristic is a binding between an aspect and a value. get_value @abstractmethod def get_value() -> Any Returns : Any : the value of the characteristic. get_aspect @abstractmethod def get_aspect() -> Aspect Returns : Aspect : the aspect of the characteristic.","title":"Characteristics"},{"location":"facts/characteristics/#brelcharacteristicsi_characteristic","text":"This module contains the interface for a characteristic. Characteristics are what makes up the context of a fact. They are a binding between an aspect and a value. There are characteristics for the 5 core aspects. ConceptCharacteristic for Aspect.CONCEPT PeriodCharacteristic for Aspect.PERIOD EntityCharacteristic for Aspect.ENTITY UnitCharacteristic for Aspect.UNIT There are also characteristics for custom aspects. Custom aspects can either be typed or explicit. A explicit aspect is an aspect where the characteristic value is one option from a list of options. For example, consider the following facts: The Foo Company has a revenue of 1000 USD in 2020 in the region North America. The Foo Company has a revenue of 2000 USD in 2020 in the region Europe. The region aspect is an explicit aspect since the options that the region aspect can take are limited to North America and Europe. A typed aspect is an aspect where the characteristic value is a value of a certain type. Brel simplifies this by making the value a string and the type a QName. For example, consider the following facts: The Bar Company has 8 employees that earn 1000 USD per month in 2020. The Bar Company has 2 employees that earn 2000 USD per month in 2020. In this case value of the fact is the number of employees. The type aspect is the 'salary per month' aspect, is an integer. ExplicitDimensionCharacteristic for explicit dimensions. TypedDimensionCharacteristic for typed dimensions. ================= author: Robin Schmidiger version: 0.1 date: 2023-12-06 =================","title":"brel.characteristics.i_characteristic"},{"location":"facts/characteristics/#icharacteristic-objects","text":"class ICharacteristic(ABC) The Interface for a characteristic. A characteristic is a binding between an aspect and a value.","title":"ICharacteristic Objects"},{"location":"facts/characteristics/#get_value","text":"@abstractmethod def get_value() -> Any Returns : Any : the value of the characteristic.","title":"get_value"},{"location":"facts/characteristics/#get_aspect","text":"@abstractmethod def get_aspect() -> Aspect Returns : Aspect : the aspect of the characteristic.","title":"get_aspect"},{"location":"facts/concept-characteristic/","text":"brel.characteristics.concept_characteristic Contains the class for representing an XBRL concept characteristic ================= author: Robin Schmidiger version: 0.2 date: 19 December 2023 ================= ConceptCharacteristic Objects class ConceptCharacteristic(ICharacteristic) Class for representing a concept characteristic. The concept characteristic links the Aspect.CONCEPT aspect to a concept. get_value def get_value() -> Concept Returns : Concept : the concept of the characteristic get_aspect def get_aspect() -> Aspect Returns : Aspect : returns the Aspect.CONCEPT aspect","title":"Concept Characteristic"},{"location":"facts/concept-characteristic/#brelcharacteristicsconcept_characteristic","text":"Contains the class for representing an XBRL concept characteristic ================= author: Robin Schmidiger version: 0.2 date: 19 December 2023 =================","title":"brel.characteristics.concept_characteristic"},{"location":"facts/concept-characteristic/#conceptcharacteristic-objects","text":"class ConceptCharacteristic(ICharacteristic) Class for representing a concept characteristic. The concept characteristic links the Aspect.CONCEPT aspect to a concept.","title":"ConceptCharacteristic Objects"},{"location":"facts/concept-characteristic/#get_value","text":"def get_value() -> Concept Returns : Concept : the concept of the characteristic","title":"get_value"},{"location":"facts/concept-characteristic/#get_aspect","text":"def get_aspect() -> Aspect Returns : Aspect : returns the Aspect.CONCEPT aspect","title":"get_aspect"},{"location":"facts/contexts/","text":"brel.brel_context This module contains the Context class. Contexts are what puts facts into context. For example, take the following fact: The Foo Corporation had a Total Revenue of 1'000'000 USD in 2020. The context of this fact would be: Entity: Foo Corporation Period: 2020 Concept: Total Revenue Unit: USD Note that the value 1000000 is not part of the context. It is the value of the fact. Contexts consist of aspects and their associated characteristics. In the example above, the aspects are Entity, Period, Concept and Unit. Characteristics are aspect-value pairs. So for example, the characteristic of the Entity aspect would be \"Foo Corporation\". Read more about Aspects and Characteristics in ==================== author: Robin Schmidiger version: 0.12 date: 07 January 2024 ==================== Context Objects class Context() Class for representing an XBRL context. an XBRL context is a collection of aspects and characteristics. There are different types of aspects: concept, period, entity, unit and dimensions The only required aspect is the concept. All aspects can only be present once. Dimensions are custom aspects, so they can be present multiple times as long as they represent different dimensions. get_aspects def get_aspects() -> list[Aspect] Get all aspects of the context. Returns : list[Aspect] : The aspects of the context. get_characteristic def get_characteristic(aspect: Aspect) -> ICharacteristic | None Get the value of an aspect. Arguments : aspect : The aspect to get the value of. Returns : Aspect|None : The value of the aspect. None if the aspect is not present in the context. has_characteristic def has_characteristic(aspect: Aspect) -> bool Check if the context has a certain aspect. Arguments : aspect : The aspect to check for. Returns : bool : True if the context has the aspect, False otherwise. get_characteristic_as_str def get_characteristic_as_str(aspect: Aspect) -> str Get the value of an aspect as a string. This is a convenience function. The representation of aspects as strings is not standardized. If the aspect is not present in the context, an empty string is returned. Arguments : aspect : The aspect to get the value of. Returns : str : The value of the aspect as a string. get_concept def get_concept() -> ConceptCharacteristic Get the concept of the context. This function is equivalent to get_characteristic(Aspect.CONCEPT) . It cannot return None, because the concept is a required aspect. Returns : ConceptCharacteristic : The concept of the context. get_period def get_period() -> PeriodCharacteristic | None Get the period of the context. This function is equivalent to get_characteristic(Aspect.PERIOD) . Returns : PeriodCharacteristic|None : The period of the context. None if the context does not have a period. get_entity def get_entity() -> EntityCharacteristic | None Get the entity of the context. This function is equivalent to get_characteristic(Aspect.ENTITY) . Returns : EntityCharacteristic|None : The entity of the context. None if the context does not have an entity. get_unit def get_unit() -> UnitCharacteristic | None Get the unit of the context. This function is equivalent to get_characteristic(Aspect.UNIT) . Returns : UnitCharacteristic|None : The unit of the context. None if the context does not have a unit.","title":"Contexts"},{"location":"facts/contexts/#brelbrel_context","text":"This module contains the Context class. Contexts are what puts facts into context. For example, take the following fact: The Foo Corporation had a Total Revenue of 1'000'000 USD in 2020. The context of this fact would be: Entity: Foo Corporation Period: 2020 Concept: Total Revenue Unit: USD Note that the value 1000000 is not part of the context. It is the value of the fact. Contexts consist of aspects and their associated characteristics. In the example above, the aspects are Entity, Period, Concept and Unit. Characteristics are aspect-value pairs. So for example, the characteristic of the Entity aspect would be \"Foo Corporation\". Read more about Aspects and Characteristics in ==================== author: Robin Schmidiger version: 0.12 date: 07 January 2024 ====================","title":"brel.brel_context"},{"location":"facts/contexts/#context-objects","text":"class Context() Class for representing an XBRL context. an XBRL context is a collection of aspects and characteristics. There are different types of aspects: concept, period, entity, unit and dimensions The only required aspect is the concept. All aspects can only be present once. Dimensions are custom aspects, so they can be present multiple times as long as they represent different dimensions.","title":"Context Objects"},{"location":"facts/contexts/#get_aspects","text":"def get_aspects() -> list[Aspect] Get all aspects of the context. Returns : list[Aspect] : The aspects of the context.","title":"get_aspects"},{"location":"facts/contexts/#get_characteristic","text":"def get_characteristic(aspect: Aspect) -> ICharacteristic | None Get the value of an aspect. Arguments : aspect : The aspect to get the value of. Returns : Aspect|None : The value of the aspect. None if the aspect is not present in the context.","title":"get_characteristic"},{"location":"facts/contexts/#has_characteristic","text":"def has_characteristic(aspect: Aspect) -> bool Check if the context has a certain aspect. Arguments : aspect : The aspect to check for. Returns : bool : True if the context has the aspect, False otherwise.","title":"has_characteristic"},{"location":"facts/contexts/#get_characteristic_as_str","text":"def get_characteristic_as_str(aspect: Aspect) -> str Get the value of an aspect as a string. This is a convenience function. The representation of aspects as strings is not standardized. If the aspect is not present in the context, an empty string is returned. Arguments : aspect : The aspect to get the value of. Returns : str : The value of the aspect as a string.","title":"get_characteristic_as_str"},{"location":"facts/contexts/#get_concept","text":"def get_concept() -> ConceptCharacteristic Get the concept of the context. This function is equivalent to get_characteristic(Aspect.CONCEPT) . It cannot return None, because the concept is a required aspect. Returns : ConceptCharacteristic : The concept of the context.","title":"get_concept"},{"location":"facts/contexts/#get_period","text":"def get_period() -> PeriodCharacteristic | None Get the period of the context. This function is equivalent to get_characteristic(Aspect.PERIOD) . Returns : PeriodCharacteristic|None : The period of the context. None if the context does not have a period.","title":"get_period"},{"location":"facts/contexts/#get_entity","text":"def get_entity() -> EntityCharacteristic | None Get the entity of the context. This function is equivalent to get_characteristic(Aspect.ENTITY) . Returns : EntityCharacteristic|None : The entity of the context. None if the context does not have an entity.","title":"get_entity"},{"location":"facts/contexts/#get_unit","text":"def get_unit() -> UnitCharacteristic | None Get the unit of the context. This function is equivalent to get_characteristic(Aspect.UNIT) . Returns : UnitCharacteristic|None : The unit of the context. None if the context does not have a unit.","title":"get_unit"},{"location":"facts/entity-characteristic/","text":"brel.characteristics.entity_characteristic Contains the class for representing an XBRL entity. ==================== author: Robin Schmidiger version: 0.5 date: 07 January 2024 ==================== EntityCharacteristic Objects class EntityCharacteristic(ICharacteristic) Class for representing an XBRL entity. An entity in XBRL is a company. It consists of an identifier. Usually the identifier is the company's CIK. Additional information about the company can be found in the entity's segment. get_aspect def get_aspect() -> Aspect Returns : Aspect : returns Aspect.ENTITY get_value def get_value() -> str returns the value of the entity characteristic, which is the entity's qname in clark notation The url of of the QName is the scheme of the entity characteristic. The local name of the QName is the id of the entity characteristic. Example of an entity characteristic value: {http:www.sec.gov/CIK}0000123456 Returns : str : the entity's QName in clark notation get_schema def get_schema() -> str Returns : str : the schema of the entity.","title":"Entity Characteristic"},{"location":"facts/entity-characteristic/#brelcharacteristicsentity_characteristic","text":"Contains the class for representing an XBRL entity. ==================== author: Robin Schmidiger version: 0.5 date: 07 January 2024 ====================","title":"brel.characteristics.entity_characteristic"},{"location":"facts/entity-characteristic/#entitycharacteristic-objects","text":"class EntityCharacteristic(ICharacteristic) Class for representing an XBRL entity. An entity in XBRL is a company. It consists of an identifier. Usually the identifier is the company's CIK. Additional information about the company can be found in the entity's segment.","title":"EntityCharacteristic Objects"},{"location":"facts/entity-characteristic/#get_aspect","text":"def get_aspect() -> Aspect Returns : Aspect : returns Aspect.ENTITY","title":"get_aspect"},{"location":"facts/entity-characteristic/#get_value","text":"def get_value() -> str returns the value of the entity characteristic, which is the entity's qname in clark notation The url of of the QName is the scheme of the entity characteristic. The local name of the QName is the id of the entity characteristic. Example of an entity characteristic value: {http:www.sec.gov/CIK}0000123456 Returns : str : the entity's QName in clark notation","title":"get_value"},{"location":"facts/entity-characteristic/#get_schema","text":"def get_schema() -> str Returns : str : the schema of the entity.","title":"get_schema"},{"location":"facts/explicit-dimension-characteristic/","text":"brel.characteristics.explicit_dimension_characteristic This module contains the class for representing an explicit dimension characteristic. Explicit members are a wrapper for a dimension- and a member report element. ==================== author: Robin Schmidiger version: 0.2 date: 2023-12-06 ==================== ExplicitDimensionCharacteristic Objects class ExplicitDimensionCharacteristic(ICharacteristic) Class for representing an explicit dimension characteristic. An explicit dimension characteristic assigns a dimension a member. The dimension is both a dimension report element as well as an aspect with the same QName as the dimension report element. The member is a member report element and the value of the explicit dimension characteristic. get_aspect def get_aspect() -> Aspect Info: Both typed and explicit dimension characteristics are not statically bound to an aspect. Returns : Aspect : the aspect of the explicit dimension characteristic. get_value def get_value() -> Member returns the value of the explicit dimension characteristic. Values of explicit dimension characteristics are member report elements. Returns : Member : the member of the explicit dimension characteristic. get_dimension def get_dimension() -> Dimension returns the name/dimension/axis of the explicit dimension characteristic. Names of explicit dimension characteristics are dimensions. This is not the same as calling get_aspect() . Returns : Dimension : the dimension of the explicit dimension characteristic. get_member def get_member() -> Member returns the member of the explicit dimension characteristic. This is equivalent to calling get_value() . Returns : Member : the member of the explicit dimension characteristic.","title":"Explicit Dimension Characteristic"},{"location":"facts/explicit-dimension-characteristic/#brelcharacteristicsexplicit_dimension_characteristic","text":"This module contains the class for representing an explicit dimension characteristic. Explicit members are a wrapper for a dimension- and a member report element. ==================== author: Robin Schmidiger version: 0.2 date: 2023-12-06 ====================","title":"brel.characteristics.explicit_dimension_characteristic"},{"location":"facts/explicit-dimension-characteristic/#explicitdimensioncharacteristic-objects","text":"class ExplicitDimensionCharacteristic(ICharacteristic) Class for representing an explicit dimension characteristic. An explicit dimension characteristic assigns a dimension a member. The dimension is both a dimension report element as well as an aspect with the same QName as the dimension report element. The member is a member report element and the value of the explicit dimension characteristic.","title":"ExplicitDimensionCharacteristic Objects"},{"location":"facts/explicit-dimension-characteristic/#get_aspect","text":"def get_aspect() -> Aspect Info: Both typed and explicit dimension characteristics are not statically bound to an aspect. Returns : Aspect : the aspect of the explicit dimension characteristic.","title":"get_aspect"},{"location":"facts/explicit-dimension-characteristic/#get_value","text":"def get_value() -> Member returns the value of the explicit dimension characteristic. Values of explicit dimension characteristics are member report elements. Returns : Member : the member of the explicit dimension characteristic.","title":"get_value"},{"location":"facts/explicit-dimension-characteristic/#get_dimension","text":"def get_dimension() -> Dimension returns the name/dimension/axis of the explicit dimension characteristic. Names of explicit dimension characteristics are dimensions. This is not the same as calling get_aspect() . Returns : Dimension : the dimension of the explicit dimension characteristic.","title":"get_dimension"},{"location":"facts/explicit-dimension-characteristic/#get_member","text":"def get_member() -> Member returns the member of the explicit dimension characteristic. This is equivalent to calling get_value() . Returns : Member : the member of the explicit dimension characteristic.","title":"get_member"},{"location":"facts/facts/","text":"brel.brel_fact This module contains the Fact class. Facts in Brel are the atomic pieces of information. They consist of a value, a context and an id. They closely resemble the facts in XBRL in the Open Information Model. To print a fact to the console, use the pprint function in the brel module. ==================== author: Robin Schmidiger version: 0.4 date: 06 January 2024 ==================== Fact Objects class Fact() The Fact class consists of a value, a context and an id. The value is the value of the fact. It is a string. The context is the context of the fact. It is a Context object. The id is the id of the fact. It is a string and is optional. get_context def get_context() -> Context Returns : Context : The context of the fact as a Context object. get_value_as_str def get_value_as_str() -> str Returns : str : The value of the fact as a string. get_value_as_qname def get_value_as_qname() -> QName Returns : The value of the fact as a QName get_value_as_int def get_value_as_int() -> int Raises : ValueError : If the value of the fact does not resolve to an int Returns : int : The value of the fact as an int get_value_as_float def get_value_as_float() -> float Raises : ValueError : If the value of the fact does not resolve to a float Returns : float : The value of the fact as a float get_value_as_bool def get_value_as_bool() -> bool Raises : ValueError : If the value of the fact does not resolve to a bool Returns : bool : The value of the fact as a bool get_value def get_value() -> str Returns : Any : The value of the fact. The type of the value depends on the type of the fact. __str__ def __str__() -> str Returns : str : The fact represented as a string. get_concept def get_concept() -> ConceptCharacteristic Returns : ConceptCharacteristic : The concept characteristic of the facts context. Equivalent to calling fact.get_context().get_concept() get_unit def get_unit() -> UnitCharacteristic | None Returns : UnitCharacteristic|None : The unit characteristic of the facts context. Returns None if the fact does not have a unit. Equivalent to calling fact.get_context().get_unit() get_period def get_period() -> PeriodCharacteristic | None Returns : PeriodCharacteristic|None : The period characteristic of the facts context. Returns None if the fact does not have a period. Equivalent to calling fact.get_context().get_period() get_aspects def get_aspects() -> list[Aspect] Returns : list[BrelAspect] : The aspects of the facts context. Equivalent to calling fact.get_context().get_aspects() get_characteristic def get_characteristic(aspect: Aspect) -> ICharacteristic | None Given an aspect, get the associated characteristic of the fact. Arguments : aspect : The aspect for which the characteristic should be returned. Returns : ICharacteristic|None : The characteristic associated with the given aspect. Returns None if the fact does not have the given aspect. Equivalent to calling fact.get_context().get_characteristic(aspect)","title":"Facts"},{"location":"facts/facts/#brelbrel_fact","text":"This module contains the Fact class. Facts in Brel are the atomic pieces of information. They consist of a value, a context and an id. They closely resemble the facts in XBRL in the Open Information Model. To print a fact to the console, use the pprint function in the brel module. ==================== author: Robin Schmidiger version: 0.4 date: 06 January 2024 ====================","title":"brel.brel_fact"},{"location":"facts/facts/#fact-objects","text":"class Fact() The Fact class consists of a value, a context and an id. The value is the value of the fact. It is a string. The context is the context of the fact. It is a Context object. The id is the id of the fact. It is a string and is optional.","title":"Fact Objects"},{"location":"facts/facts/#get_context","text":"def get_context() -> Context Returns : Context : The context of the fact as a Context object.","title":"get_context"},{"location":"facts/facts/#get_value_as_str","text":"def get_value_as_str() -> str Returns : str : The value of the fact as a string.","title":"get_value_as_str"},{"location":"facts/facts/#get_value_as_qname","text":"def get_value_as_qname() -> QName Returns : The value of the fact as a QName","title":"get_value_as_qname"},{"location":"facts/facts/#get_value_as_int","text":"def get_value_as_int() -> int Raises : ValueError : If the value of the fact does not resolve to an int Returns : int : The value of the fact as an int","title":"get_value_as_int"},{"location":"facts/facts/#get_value_as_float","text":"def get_value_as_float() -> float Raises : ValueError : If the value of the fact does not resolve to a float Returns : float : The value of the fact as a float","title":"get_value_as_float"},{"location":"facts/facts/#get_value_as_bool","text":"def get_value_as_bool() -> bool Raises : ValueError : If the value of the fact does not resolve to a bool Returns : bool : The value of the fact as a bool","title":"get_value_as_bool"},{"location":"facts/facts/#get_value","text":"def get_value() -> str Returns : Any : The value of the fact. The type of the value depends on the type of the fact.","title":"get_value"},{"location":"facts/facts/#__str__","text":"def __str__() -> str Returns : str : The fact represented as a string.","title":"__str__"},{"location":"facts/facts/#get_concept","text":"def get_concept() -> ConceptCharacteristic Returns : ConceptCharacteristic : The concept characteristic of the facts context. Equivalent to calling fact.get_context().get_concept()","title":"get_concept"},{"location":"facts/facts/#get_unit","text":"def get_unit() -> UnitCharacteristic | None Returns : UnitCharacteristic|None : The unit characteristic of the facts context. Returns None if the fact does not have a unit. Equivalent to calling fact.get_context().get_unit()","title":"get_unit"},{"location":"facts/facts/#get_period","text":"def get_period() -> PeriodCharacteristic | None Returns : PeriodCharacteristic|None : The period characteristic of the facts context. Returns None if the fact does not have a period. Equivalent to calling fact.get_context().get_period()","title":"get_period"},{"location":"facts/facts/#get_aspects","text":"def get_aspects() -> list[Aspect] Returns : list[BrelAspect] : The aspects of the facts context. Equivalent to calling fact.get_context().get_aspects()","title":"get_aspects"},{"location":"facts/facts/#get_characteristic","text":"def get_characteristic(aspect: Aspect) -> ICharacteristic | None Given an aspect, get the associated characteristic of the fact. Arguments : aspect : The aspect for which the characteristic should be returned. Returns : ICharacteristic|None : The characteristic associated with the given aspect. Returns None if the fact does not have the given aspect. Equivalent to calling fact.get_context().get_characteristic(aspect)","title":"get_characteristic"},{"location":"facts/period-characteristic/","text":"brel.characteristics.period_characteristic This module contains the PeriodCharacteristic class, which represents an XBRL period characteristic. A period characteristic associates the aspect Aspect.PERIOD with a value. This value can be an instant or a duration. An instant consists of a single datetime.date instance. A duration consists of two datetime.date instances, a start date and an end date. ==================== author: Robin Schmidiger version: 0.5 date: 08 Jan 2024 ==================== PeriodCharacteristic Objects class PeriodCharacteristic(ICharacteristic) Class for representing an XBRL period characteristic. A period characteristic is either a duration or an instant. Use the is_instant() method to check if the period is an instant or a duration. If the period is an instant, use the get_instant_period() method to get the instant date as a datetime.date instance. if the period is a duration, use the get_start_period() and get_end_period() methods to get the start and end dates as datetime.date instances. A quirk of the PeriodCharacteristic.get_value() method is that it returns the period characteristic itself. This is because the standard python package datetime does not have a class for representing a period as specified by XBRL. is_instant def is_instant() -> bool Returns : bool : True if the period is an instant, False otherwise get_start_period def get_start_period() -> datetime.date Raises : ValueError : if the period is an instant. Use 'is_instant' to check if the period is an instant. Returns : datetime.date : the start date of the period as a datetime.date instance. get_end_period def get_end_period() -> datetime.date Raises : ValueError : if the period is an instant. Use 'is_instant' to check if the period is an instant. Returns : datetime.date : the end date of the period as a datetime.date instance. get_instant_period def get_instant_period() -> datetime.date Raises : ValueError : if the period is a duration. Use 'is_instant' to check if the period is an instant. Returns : datetime.date : the instant date of the period as a datetime.date instance. get_value def get_value() -> \"PeriodCharacteristic\" Returns : PeriodCharacteristic : the period characteristic itself get_aspect def get_aspect() -> Aspect Returns : Aspect : the aspect of the period characteristic, which is Aspect.PERIOD","title":"Period Characteristic"},{"location":"facts/period-characteristic/#brelcharacteristicsperiod_characteristic","text":"This module contains the PeriodCharacteristic class, which represents an XBRL period characteristic. A period characteristic associates the aspect Aspect.PERIOD with a value. This value can be an instant or a duration. An instant consists of a single datetime.date instance. A duration consists of two datetime.date instances, a start date and an end date. ==================== author: Robin Schmidiger version: 0.5 date: 08 Jan 2024 ====================","title":"brel.characteristics.period_characteristic"},{"location":"facts/period-characteristic/#periodcharacteristic-objects","text":"class PeriodCharacteristic(ICharacteristic) Class for representing an XBRL period characteristic. A period characteristic is either a duration or an instant. Use the is_instant() method to check if the period is an instant or a duration. If the period is an instant, use the get_instant_period() method to get the instant date as a datetime.date instance. if the period is a duration, use the get_start_period() and get_end_period() methods to get the start and end dates as datetime.date instances. A quirk of the PeriodCharacteristic.get_value() method is that it returns the period characteristic itself. This is because the standard python package datetime does not have a class for representing a period as specified by XBRL.","title":"PeriodCharacteristic Objects"},{"location":"facts/period-characteristic/#is_instant","text":"def is_instant() -> bool Returns : bool : True if the period is an instant, False otherwise","title":"is_instant"},{"location":"facts/period-characteristic/#get_start_period","text":"def get_start_period() -> datetime.date Raises : ValueError : if the period is an instant. Use 'is_instant' to check if the period is an instant. Returns : datetime.date : the start date of the period as a datetime.date instance.","title":"get_start_period"},{"location":"facts/period-characteristic/#get_end_period","text":"def get_end_period() -> datetime.date Raises : ValueError : if the period is an instant. Use 'is_instant' to check if the period is an instant. Returns : datetime.date : the end date of the period as a datetime.date instance.","title":"get_end_period"},{"location":"facts/period-characteristic/#get_instant_period","text":"def get_instant_period() -> datetime.date Raises : ValueError : if the period is a duration. Use 'is_instant' to check if the period is an instant. Returns : datetime.date : the instant date of the period as a datetime.date instance.","title":"get_instant_period"},{"location":"facts/period-characteristic/#get_value","text":"def get_value() -> \"PeriodCharacteristic\" Returns : PeriodCharacteristic : the period characteristic itself","title":"get_value"},{"location":"facts/period-characteristic/#get_aspect","text":"def get_aspect() -> Aspect Returns : Aspect : the aspect of the period characteristic, which is Aspect.PERIOD","title":"get_aspect"},{"location":"facts/typed-dimension-characteristic/","text":"brel.characteristics.typed_dimension_characteristic This module contains the class for the typed dimension characteristic in Brel. ==================== author: Robin Schmidiger version: 0.4 date: 19 December 2023 ==================== TypedDimensionCharacteristic Objects class TypedDimensionCharacteristic(ICharacteristic) Class for representing a typed dimension characteristic. A typed dimension characteristic assigns a dimension aspect a value. In Brel, the type of the value is omitted and the value is always a string. get_aspect def get_aspect() -> Aspect Info: Both typed and explicit dimension characteristics are not core characteristics and therefore not available as attributes of the Aspect class. Returns : Aspect : the aspect of the explicit dimension characteristic. get_value def get_value() -> str Returns : str : the value of the typed dimension characteristic as a string. get_dimension def get_dimension() -> Dimension Info: this is not the same as calling get_aspect() . Returns : Dimension : the dimension of the typed dimension characteristic.","title":"Typed Dimension Characteristic"},{"location":"facts/typed-dimension-characteristic/#brelcharacteristicstyped_dimension_characteristic","text":"This module contains the class for the typed dimension characteristic in Brel. ==================== author: Robin Schmidiger version: 0.4 date: 19 December 2023 ====================","title":"brel.characteristics.typed_dimension_characteristic"},{"location":"facts/typed-dimension-characteristic/#typeddimensioncharacteristic-objects","text":"class TypedDimensionCharacteristic(ICharacteristic) Class for representing a typed dimension characteristic. A typed dimension characteristic assigns a dimension aspect a value. In Brel, the type of the value is omitted and the value is always a string.","title":"TypedDimensionCharacteristic Objects"},{"location":"facts/typed-dimension-characteristic/#get_aspect","text":"def get_aspect() -> Aspect Info: Both typed and explicit dimension characteristics are not core characteristics and therefore not available as attributes of the Aspect class. Returns : Aspect : the aspect of the explicit dimension characteristic.","title":"get_aspect"},{"location":"facts/typed-dimension-characteristic/#get_value","text":"def get_value() -> str Returns : str : the value of the typed dimension characteristic as a string.","title":"get_value"},{"location":"facts/typed-dimension-characteristic/#get_dimension","text":"def get_dimension() -> Dimension Info: this is not the same as calling get_aspect() . Returns : Dimension : the dimension of the typed dimension characteristic.","title":"get_dimension"},{"location":"facts/unit-characteristic/","text":"brel.characteristics.unit_characteristic This module contains the class for representing xbrl unit characteristics. A unit characteristic associates the aspect Aspect.UNIT with a value. In case of the UnitCharacteristic class, the value is a string. However, the UnitCharacteristic can also handle more complex units consisting of numerators and denominators. ==================== author: Robin Schmidiger version: 0.2 date: 07 January 2024 ==================== UnitCharacteristic Objects class UnitCharacteristic(ICharacteristic) Class for representing an XBRL unit characteristic. A unit characteristic associates the aspect Aspect.UNIT with a value and implements the ICharacteristic interface. A unit can be identified by its name, which usually indicates how the unit is composed. Examples: \"usd\", \"sharesPerUSD\", \"shares\" A unit consists of numerators and denominators, which are lists of QNames. Most units are simple and consist of a single QName. You can use the is_simple() method to check if the unit is simple. You can get the numerators and denominators of the unit using the get_numerators() and get_denominators() methods respectively. The unit characteristic does have a connection to the concept characteristic. Namely, if the concept characteristic's concept is a monetary concept, the unit's numerators and denominators must be defined in the iso4217 namespace. get_aspect def get_aspect() -> Aspect Returns : Aspect : returns Aspect.UNIT get_numerators def get_numerators() -> list[QName] Returns : list[QName] : all numerators of the unit get_denominators def get_denominators() -> list[QName] Returns : list[QName] : all denominators of the unit get_value def get_value() -> str info: this is different from the numerators/denominators of the unit. It is the name of the unit. Returns : str : the name of the unit is_simple def is_simple() -> bool A unit is simple if it has exactly one numerator and no denominators Returns : bool : True 'IFF' the unit is simple, False otherwise","title":"Unit Characteristic"},{"location":"facts/unit-characteristic/#brelcharacteristicsunit_characteristic","text":"This module contains the class for representing xbrl unit characteristics. A unit characteristic associates the aspect Aspect.UNIT with a value. In case of the UnitCharacteristic class, the value is a string. However, the UnitCharacteristic can also handle more complex units consisting of numerators and denominators. ==================== author: Robin Schmidiger version: 0.2 date: 07 January 2024 ====================","title":"brel.characteristics.unit_characteristic"},{"location":"facts/unit-characteristic/#unitcharacteristic-objects","text":"class UnitCharacteristic(ICharacteristic) Class for representing an XBRL unit characteristic. A unit characteristic associates the aspect Aspect.UNIT with a value and implements the ICharacteristic interface. A unit can be identified by its name, which usually indicates how the unit is composed. Examples: \"usd\", \"sharesPerUSD\", \"shares\" A unit consists of numerators and denominators, which are lists of QNames. Most units are simple and consist of a single QName. You can use the is_simple() method to check if the unit is simple. You can get the numerators and denominators of the unit using the get_numerators() and get_denominators() methods respectively. The unit characteristic does have a connection to the concept characteristic. Namely, if the concept characteristic's concept is a monetary concept, the unit's numerators and denominators must be defined in the iso4217 namespace.","title":"UnitCharacteristic Objects"},{"location":"facts/unit-characteristic/#get_aspect","text":"def get_aspect() -> Aspect Returns : Aspect : returns Aspect.UNIT","title":"get_aspect"},{"location":"facts/unit-characteristic/#get_numerators","text":"def get_numerators() -> list[QName] Returns : list[QName] : all numerators of the unit","title":"get_numerators"},{"location":"facts/unit-characteristic/#get_denominators","text":"def get_denominators() -> list[QName] Returns : list[QName] : all denominators of the unit","title":"get_denominators"},{"location":"facts/unit-characteristic/#get_value","text":"def get_value() -> str info: this is different from the numerators/denominators of the unit. It is the name of the unit. Returns : str : the name of the unit","title":"get_value"},{"location":"facts/unit-characteristic/#is_simple","text":"def is_simple() -> bool A unit is simple if it has exactly one numerator and no denominators Returns : bool : True 'IFF' the unit is simple, False otherwise","title":"is_simple"},{"location":"qnames/namespace-normalization/","text":"brel.parsers.XML.xml_namespace_normalizer This module contains the XML namespace normalizer. It is not intended to be used by the user directly. Rather, it is used by the XML parser to normalize the namespace mappings. In XML, namespaces can be defined per element. Therefore, the same prefix can map to different urls and the same url can map to different prefixes. It all depends on the context in which the prefix is used. From a user perspective, this is very confusing. When a user looks for e.g. us-gaap:Assets, he usually doesn't care if it is us-gaap's 2022 or 2023 version. Also, if the filing calls the prefix us-gaap1 instead of us-gaap for some contexts, then the user will have to know this and use the correct prefix. Namespace normalizing turns the nested namespace mappings into a flat namespace mapping. It also generates redirects and renames for the prefixes. For the example above, it would generate the following mapping: us-gaap -> us-gaap-2023-01-31 redirect: us-gaap1 -> us-gaap More precisely, it does the following: It groups the prefix->url mappings by their unversioned url. For each group, it picks the main prefix and the latest version of the url. For each non-main prefix, it generates a redirect to the main prefix. Renames are generated if two completely different urls are mapped to the same prefix. In that case, the name of the prefix is changed to a new prefix. A rename has the following form: old_url -> (old_prefix, new_prefix) ==================== author: Robin Schmidiger version: 0.4 date: 21 January 2024 ==================== normalize_nsmap def normalize_nsmap( namespace_mappings: list[dict[str, str]]) -> dict[str, dict[str, str]] Given a list of namespace mappings, normalize the namespace mappings and returns the normalized namespace mapping and the redirects. A mapping is considered normalized if there is a 1:1 mapping between prefixes and urls. If a prefix maps to multiple urls, then the latest version of the url is chosen. If multiple prefixes map to the same url, then the shortest prefix is chosen as the main prefix. The other prefixes are redirected to the main prefix. Arguments : namespace_mappings : A list of namespace mappings. Returns : dict : A dictionary containing the normalized namespace mapping and the redirects.","title":"Namespace normalization"},{"location":"qnames/namespace-normalization/#brelparsersxmlxml_namespace_normalizer","text":"This module contains the XML namespace normalizer. It is not intended to be used by the user directly. Rather, it is used by the XML parser to normalize the namespace mappings. In XML, namespaces can be defined per element. Therefore, the same prefix can map to different urls and the same url can map to different prefixes. It all depends on the context in which the prefix is used. From a user perspective, this is very confusing. When a user looks for e.g. us-gaap:Assets, he usually doesn't care if it is us-gaap's 2022 or 2023 version. Also, if the filing calls the prefix us-gaap1 instead of us-gaap for some contexts, then the user will have to know this and use the correct prefix. Namespace normalizing turns the nested namespace mappings into a flat namespace mapping. It also generates redirects and renames for the prefixes. For the example above, it would generate the following mapping: us-gaap -> us-gaap-2023-01-31 redirect: us-gaap1 -> us-gaap More precisely, it does the following: It groups the prefix->url mappings by their unversioned url. For each group, it picks the main prefix and the latest version of the url. For each non-main prefix, it generates a redirect to the main prefix. Renames are generated if two completely different urls are mapped to the same prefix. In that case, the name of the prefix is changed to a new prefix. A rename has the following form: old_url -> (old_prefix, new_prefix) ==================== author: Robin Schmidiger version: 0.4 date: 21 January 2024 ====================","title":"brel.parsers.XML.xml_namespace_normalizer"},{"location":"qnames/namespace-normalization/#normalize_nsmap","text":"def normalize_nsmap( namespace_mappings: list[dict[str, str]]) -> dict[str, dict[str, str]] Given a list of namespace mappings, normalize the namespace mappings and returns the normalized namespace mapping and the redirects. A mapping is considered normalized if there is a 1:1 mapping between prefixes and urls. If a prefix maps to multiple urls, then the latest version of the url is chosen. If multiple prefixes map to the same url, then the shortest prefix is chosen as the main prefix. The other prefixes are redirected to the main prefix. Arguments : namespace_mappings : A list of namespace mappings. Returns : dict : A dictionary containing the normalized namespace mapping and the redirects.","title":"normalize_nsmap"},{"location":"qnames/qnames-and-namespace-maps/","text":"brel.qname This module contains the QName class and the QNameNSMap class. The QName class represents a qualified name. The QNameNSMap class represents a namespace map. ==================== author: Robin Schmidiger version: 0.6 date: 06 January 2024 ==================== QName Objects class QName() This class represents a qualified name. Qualified names are used in XML and XBRL to identify elements. Brel re-uses qualified names to identify report elements, types, etc. in the report. A qualified name consists of a URI, a prefix and a local name. The URI identifies the namespace of the element. The prefix is a short string that is used to identify the namespace. The local name is the name of the element within the namespace. An example of a qualified name is us-gaap:Assets. The URI is http://fasb.org/us-gaap/2019-01-31 The prefix is us-gaap and acts as an abbreviation for the URI The local name is Assets The QName class is closely related to the QNameNSMap class. The QNameNSMap class is used to map prefixes to URIs and vice versa. When creating a QName, sometimes either the prefix or the URI is unknown. In this case, the QNameNSMap class is used to find the missing information. There is usually only one QNameNSMap object per report. It is created when the report is created and then passed to the QName constructor. __init__ def __init__(uri: str, prefix: str, local_name: str, nsmap: \"QNameNSMap\") Creates a QName object. Note that this constructor changes the prefix if there is a prefix redirect in the QNameNSMap . Arguments : uri : str containing the URI. Must be a valid URL prefix : str containing the prefix local_name : str containing the local name nsmap : QNameNSMap containing the namespace map Raises : ValueError : if there is a conflict with the namespace map get_URL def get_URL() -> str Returns : str : containing the URI get_prefix def get_prefix() -> str Returns : str : containing the prefix get_local_name def get_local_name() -> str Returns : str : containing the local name get_nsmap def get_nsmap() -> \"QNameNSMap\" Returns : QNameNSMap : containing the namespace map. get def get() -> str Returns : str : representation of the qualified name. it does not substitute the prefix with the URI. example: us-gaap:Assets __str__ def __str__() -> str Returns : str : representation of the qualified name. Functionally equivalent to QName.get() __eq__ def __eq__(__value: object) -> bool Checks if the QName self is equal to the QName __value. Two QNames are equal if - the local name is equal - the prefix is equal Note that the URI is not considered when checking for equality. This is because Brel does not allow two completely different URIs to map to the same prefix. Two URIs are completely different if they are not versions of the same URI. Example: - http://www.xbrl.org/2003/instance and http://www.xbrl.org/2020/instance are versions of the same URI. - http://www.xbrl.org/2003/instance and http://www.xbrl.org/2003/taxonomy are not versions of the same URI. Arguments : __value : object containing the QName to compare with. Returns : bool : True if __value is a QName and it is equal to self, False otherwise. __hash__ def __hash__() -> int Returns : int : containing the hash of the QName resolve def resolve() -> str produces the clark notation of the qualified name it substitutes the prefix with the URI example: {http://www.xbrl.org/2003/instance}Assets Returns : str : containing the clark notation of the qualified name from_string @classmethod def from_string(cls, qname_string: str, nsmap: \"QNameNSMap\") -> \"QName\" Creates a QName from a string representation of a QName The string representation must be in one of the following formats: - {URL}local_name - prefix:local_name Furthermore, The prefix and the URL must be known. So there must be an entry in the namespace map for the prefix and the URL. Arguments : qname_string : str containing the string representation of the QName nsmap : QNameNSMap containing the namespace map Raises : ValueError : if the string representation is not valid or if the prefix or the URL is not known Returns : QName : the QName created from the string representation is_str_qname @classmethod def is_str_qname(cls, qname_string: str, nsmap: \"QNameNSMap\") -> bool Checks if a string represents a QName and could be parsed by QName.from_string() Arguments : qname_string : str containing the string representation of the QName nsmap : QNameNSMap containing the namespace map Returns : bool : True if the string represents a QName, False otherwise QNameNSMap Objects class QNameNSMap() This class represents a namespace map used to map prefixes to URIs and vice versa. It is used by the QName class to create QNames from strings. It requires a 1:1 mapping between prefixes and URIs. A QNameNSMap introduces two concepts to achieve this: prefix redirects and prefix renames. Prefix redirects For many reports, it is possible that the same namespace is used with different prefixes. For example, the namespace http://fasb.org/us-gaap/2020 is used with the prefixes us-gaap and us-gaap-ci. This is not allowed in Brel. So one of the prefixes must be redirected to the other. In case of the example above, the prefix us-gaap-ci must be redirected to us-gaap. This can be done as follows: nsmap.add_redirect(\"us-gaap-ci\", \"us-gaap\") Prefix renames Sometimes, the same prefix is used for different namespaces. For example, the prefix 'types' is used for the namespaces http://fasb.org/us-types/2020 and http://fasb.org/uk-types/2020. This is not allowed in Brel. So one of the prefixes must be renamed. In case of the example above, the prefix 'types' could be renamed to 'us-types' or 'uk-types'. This can be done as follows: nsmap.rename(\"http://fasb.org/us-types/2020\", \"us-types\") Now whenever a QName is created with the prefix 'namespaces', the prefix will be replaced with 'us-types'. __init__ def __init__() -> None Creates a QNameNSMap object add_to_nsmap def add_to_nsmap(url: str, prefix: str) -> None Adds a prefix to the namespace map Arguments : url : str containing the URL prefix : str containing the prefix Raises : ValueError : if the URL/prefix is already in the namespace map, but mapped to a different prefix/URL than the one provided add_redirect def add_redirect(redirect_from: str, redirect_to: str) -> None Adds a prefix redirect to the namespace map. When creating a new QName, the redirect_from prefix will be replaced with the redirect_to prefix. Arguments : redirect_from : str containing the prefix that should be redirected redirect_to : str containing the prefix that should be redirected to Raises : ValueError : if the redirect destination does not exist in the namespace map or if the redirect source already exists in the namespace map get_redirect def get_redirect(redirect_from: str) -> str | None Gets the redirect destination for a prefix redirect Arguments : redirect_from : str containing the prefix that should be redirected Returns : str : containing the prefix that should be redirected to rename def rename(rename_uri: str, rename_prefix: str) -> None Given a URI and a prefix, changes the mapping of the URI to the prefix. When creating a new QName and only the URI is known, the prefix will be replaced with the rename_prefix. Arguments : rename_uri : str containing the URI rename_prefix : str containing the prefix Raises : ValueError : if the URI does not exist in the namespace map get_prefix def get_prefix(url: str) -> str | None Gets the prefix for a URL :param url: str containing the URL. :return str | None: The prefix for the URL. None if the URL is not in the namespace map get_url def get_url(prefix: str) -> str | None Gets the URL for a prefix :param prefix: str containing the prefix :return str | None: The URL for the prefix. None if the prefix is not in the namespace map get_nsmap def get_nsmap() -> dict[str, str] Returns the namespace map as a dict. This is deprecated. Use QNameNSMap.get_prefix() :return dict[str, str]: containing the namespace map","title":"QNames and Namespace maps"},{"location":"qnames/qnames-and-namespace-maps/#brelqname","text":"This module contains the QName class and the QNameNSMap class. The QName class represents a qualified name. The QNameNSMap class represents a namespace map. ==================== author: Robin Schmidiger version: 0.6 date: 06 January 2024 ====================","title":"brel.qname"},{"location":"qnames/qnames-and-namespace-maps/#qname-objects","text":"class QName() This class represents a qualified name. Qualified names are used in XML and XBRL to identify elements. Brel re-uses qualified names to identify report elements, types, etc. in the report. A qualified name consists of a URI, a prefix and a local name. The URI identifies the namespace of the element. The prefix is a short string that is used to identify the namespace. The local name is the name of the element within the namespace. An example of a qualified name is us-gaap:Assets. The URI is http://fasb.org/us-gaap/2019-01-31 The prefix is us-gaap and acts as an abbreviation for the URI The local name is Assets The QName class is closely related to the QNameNSMap class. The QNameNSMap class is used to map prefixes to URIs and vice versa. When creating a QName, sometimes either the prefix or the URI is unknown. In this case, the QNameNSMap class is used to find the missing information. There is usually only one QNameNSMap object per report. It is created when the report is created and then passed to the QName constructor.","title":"QName Objects"},{"location":"qnames/qnames-and-namespace-maps/#__init__","text":"def __init__(uri: str, prefix: str, local_name: str, nsmap: \"QNameNSMap\") Creates a QName object. Note that this constructor changes the prefix if there is a prefix redirect in the QNameNSMap . Arguments : uri : str containing the URI. Must be a valid URL prefix : str containing the prefix local_name : str containing the local name nsmap : QNameNSMap containing the namespace map Raises : ValueError : if there is a conflict with the namespace map","title":"__init__"},{"location":"qnames/qnames-and-namespace-maps/#get_url","text":"def get_URL() -> str Returns : str : containing the URI","title":"get_URL"},{"location":"qnames/qnames-and-namespace-maps/#get_prefix","text":"def get_prefix() -> str Returns : str : containing the prefix","title":"get_prefix"},{"location":"qnames/qnames-and-namespace-maps/#get_local_name","text":"def get_local_name() -> str Returns : str : containing the local name","title":"get_local_name"},{"location":"qnames/qnames-and-namespace-maps/#get_nsmap","text":"def get_nsmap() -> \"QNameNSMap\" Returns : QNameNSMap : containing the namespace map.","title":"get_nsmap"},{"location":"qnames/qnames-and-namespace-maps/#get","text":"def get() -> str Returns : str : representation of the qualified name. it does not substitute the prefix with the URI. example: us-gaap:Assets","title":"get"},{"location":"qnames/qnames-and-namespace-maps/#__str__","text":"def __str__() -> str Returns : str : representation of the qualified name. Functionally equivalent to QName.get()","title":"__str__"},{"location":"qnames/qnames-and-namespace-maps/#__eq__","text":"def __eq__(__value: object) -> bool Checks if the QName self is equal to the QName __value. Two QNames are equal if - the local name is equal - the prefix is equal Note that the URI is not considered when checking for equality. This is because Brel does not allow two completely different URIs to map to the same prefix. Two URIs are completely different if they are not versions of the same URI. Example: - http://www.xbrl.org/2003/instance and http://www.xbrl.org/2020/instance are versions of the same URI. - http://www.xbrl.org/2003/instance and http://www.xbrl.org/2003/taxonomy are not versions of the same URI. Arguments : __value : object containing the QName to compare with. Returns : bool : True if __value is a QName and it is equal to self, False otherwise.","title":"__eq__"},{"location":"qnames/qnames-and-namespace-maps/#__hash__","text":"def __hash__() -> int Returns : int : containing the hash of the QName","title":"__hash__"},{"location":"qnames/qnames-and-namespace-maps/#resolve","text":"def resolve() -> str produces the clark notation of the qualified name it substitutes the prefix with the URI example: {http://www.xbrl.org/2003/instance}Assets Returns : str : containing the clark notation of the qualified name","title":"resolve"},{"location":"qnames/qnames-and-namespace-maps/#from_string","text":"@classmethod def from_string(cls, qname_string: str, nsmap: \"QNameNSMap\") -> \"QName\" Creates a QName from a string representation of a QName The string representation must be in one of the following formats: - {URL}local_name - prefix:local_name Furthermore, The prefix and the URL must be known. So there must be an entry in the namespace map for the prefix and the URL. Arguments : qname_string : str containing the string representation of the QName nsmap : QNameNSMap containing the namespace map Raises : ValueError : if the string representation is not valid or if the prefix or the URL is not known Returns : QName : the QName created from the string representation","title":"from_string"},{"location":"qnames/qnames-and-namespace-maps/#is_str_qname","text":"@classmethod def is_str_qname(cls, qname_string: str, nsmap: \"QNameNSMap\") -> bool Checks if a string represents a QName and could be parsed by QName.from_string() Arguments : qname_string : str containing the string representation of the QName nsmap : QNameNSMap containing the namespace map Returns : bool : True if the string represents a QName, False otherwise","title":"is_str_qname"},{"location":"qnames/qnames-and-namespace-maps/#qnamensmap-objects","text":"class QNameNSMap() This class represents a namespace map used to map prefixes to URIs and vice versa. It is used by the QName class to create QNames from strings. It requires a 1:1 mapping between prefixes and URIs. A QNameNSMap introduces two concepts to achieve this: prefix redirects and prefix renames. Prefix redirects For many reports, it is possible that the same namespace is used with different prefixes. For example, the namespace http://fasb.org/us-gaap/2020 is used with the prefixes us-gaap and us-gaap-ci. This is not allowed in Brel. So one of the prefixes must be redirected to the other. In case of the example above, the prefix us-gaap-ci must be redirected to us-gaap. This can be done as follows: nsmap.add_redirect(\"us-gaap-ci\", \"us-gaap\") Prefix renames Sometimes, the same prefix is used for different namespaces. For example, the prefix 'types' is used for the namespaces http://fasb.org/us-types/2020 and http://fasb.org/uk-types/2020. This is not allowed in Brel. So one of the prefixes must be renamed. In case of the example above, the prefix 'types' could be renamed to 'us-types' or 'uk-types'. This can be done as follows: nsmap.rename(\"http://fasb.org/us-types/2020\", \"us-types\") Now whenever a QName is created with the prefix 'namespaces', the prefix will be replaced with 'us-types'.","title":"QNameNSMap Objects"},{"location":"qnames/qnames-and-namespace-maps/#__init___1","text":"def __init__() -> None Creates a QNameNSMap object","title":"__init__"},{"location":"qnames/qnames-and-namespace-maps/#add_to_nsmap","text":"def add_to_nsmap(url: str, prefix: str) -> None Adds a prefix to the namespace map Arguments : url : str containing the URL prefix : str containing the prefix Raises : ValueError : if the URL/prefix is already in the namespace map, but mapped to a different prefix/URL than the one provided","title":"add_to_nsmap"},{"location":"qnames/qnames-and-namespace-maps/#add_redirect","text":"def add_redirect(redirect_from: str, redirect_to: str) -> None Adds a prefix redirect to the namespace map. When creating a new QName, the redirect_from prefix will be replaced with the redirect_to prefix. Arguments : redirect_from : str containing the prefix that should be redirected redirect_to : str containing the prefix that should be redirected to Raises : ValueError : if the redirect destination does not exist in the namespace map or if the redirect source already exists in the namespace map","title":"add_redirect"},{"location":"qnames/qnames-and-namespace-maps/#get_redirect","text":"def get_redirect(redirect_from: str) -> str | None Gets the redirect destination for a prefix redirect Arguments : redirect_from : str containing the prefix that should be redirected Returns : str : containing the prefix that should be redirected to","title":"get_redirect"},{"location":"qnames/qnames-and-namespace-maps/#rename","text":"def rename(rename_uri: str, rename_prefix: str) -> None Given a URI and a prefix, changes the mapping of the URI to the prefix. When creating a new QName and only the URI is known, the prefix will be replaced with the rename_prefix. Arguments : rename_uri : str containing the URI rename_prefix : str containing the prefix Raises : ValueError : if the URI does not exist in the namespace map","title":"rename"},{"location":"qnames/qnames-and-namespace-maps/#get_prefix_1","text":"def get_prefix(url: str) -> str | None Gets the prefix for a URL :param url: str containing the URL. :return str | None: The prefix for the URL. None if the URL is not in the namespace map","title":"get_prefix"},{"location":"qnames/qnames-and-namespace-maps/#get_url_1","text":"def get_url(prefix: str) -> str | None Gets the URL for a prefix :param prefix: str containing the prefix :return str | None: The URL for the prefix. None if the prefix is not in the namespace map","title":"get_url"},{"location":"qnames/qnames-and-namespace-maps/#get_nsmap_1","text":"def get_nsmap() -> dict[str, str] Returns the namespace map as a dict. This is deprecated. Use QNameNSMap.get_prefix() :return dict[str, str]: containing the namespace map","title":"get_nsmap"},{"location":"report-elements/abstract/","text":"brel.reportelements.abstract This module contains the Abstract class. An abstract a kind of report element that is used to group other report elements. ==================== author: Robin Schmidiger version: 0.2 date: 30 October 2023 ==================== Abstract Objects class Abstract(IReportElement) Class representing an abstract in a BREL report. An abstract is a kind of report element that is used to group other report elements. They are often used in presentation networks to build a hierarchy of concepts. The Abstract class implements the IReportElement interface. get_name def get_name() -> QName Get the name of the abstract element. Returns : QName : containing the name of the abstract element get_labels def get_labels() -> list[BrelLabel] Get the labels of the abstract element. Returns : list[Label] : contains the labels of the abstract element","title":"Abstract"},{"location":"report-elements/abstract/#brelreportelementsabstract","text":"This module contains the Abstract class. An abstract a kind of report element that is used to group other report elements. ==================== author: Robin Schmidiger version: 0.2 date: 30 October 2023 ====================","title":"brel.reportelements.abstract"},{"location":"report-elements/abstract/#abstract-objects","text":"class Abstract(IReportElement) Class representing an abstract in a BREL report. An abstract is a kind of report element that is used to group other report elements. They are often used in presentation networks to build a hierarchy of concepts. The Abstract class implements the IReportElement interface.","title":"Abstract Objects"},{"location":"report-elements/abstract/#get_name","text":"def get_name() -> QName Get the name of the abstract element. Returns : QName : containing the name of the abstract element","title":"get_name"},{"location":"report-elements/abstract/#get_labels","text":"def get_labels() -> list[BrelLabel] Get the labels of the abstract element. Returns : list[Label] : contains the labels of the abstract element","title":"get_labels"},{"location":"report-elements/concept/","text":"brel.reportelements.concept This module contains the Concept class. A Concept is a data item that can be reported on. Concepts in BREL reports are the same as concepts in XBRL reports. For more information on concepts, see the XBRL 2.1 specification ==================== author: Robin Schmidiger version: 0.5 date: 04 December 2023 ==================== Concept Objects class Concept(IReportElement) Class representing a concept in a BREL report. A concept is a data item that can be reported on. Concepts in BREL reports are the same as concepts in XBRL reports. For more information on concepts, see the XBRL 2.1 specification. A short summary of the most important attributes of a concept: It is defined in the XBRL taxonomy. So in the .xsd files in the DTS. It has a name, which is a QName. This has to be unique in the DTS. It has a data type, which is a QName. It has a period type, which can be either instant or duration. (optional) It has a balance type, which can be either credit or debit. (optional) It can be nillable, which is either true or false. If the attribute is not present, it defaults to false. get_name def get_name() -> QName Get the name of the concept. Returns : QName : the QName of the concept get_labels def get_labels() -> list[BrelLabel] Get the labels of the concept. Returns : list[Label] : all labels of the concept get_period_type def get_period_type() -> str Get the period type of the concept. Returns : str : the period type of the concept get_data_type def get_data_type() -> str Get the data type of the concept. Returns : str : the data type of the concept get_balance_type def get_balance_type() -> str | None Get the balance type of the concept. Returns : str|None : the balance type of the concept. None if the concept has no balance type. is_nillable def is_nillable() -> bool Check if the concept is nillable. Returns : bool : True 'IFF' the concept is nillable, False otherwise","title":"Concept"},{"location":"report-elements/concept/#brelreportelementsconcept","text":"This module contains the Concept class. A Concept is a data item that can be reported on. Concepts in BREL reports are the same as concepts in XBRL reports. For more information on concepts, see the XBRL 2.1 specification ==================== author: Robin Schmidiger version: 0.5 date: 04 December 2023 ====================","title":"brel.reportelements.concept"},{"location":"report-elements/concept/#concept-objects","text":"class Concept(IReportElement) Class representing a concept in a BREL report. A concept is a data item that can be reported on. Concepts in BREL reports are the same as concepts in XBRL reports. For more information on concepts, see the XBRL 2.1 specification. A short summary of the most important attributes of a concept: It is defined in the XBRL taxonomy. So in the .xsd files in the DTS. It has a name, which is a QName. This has to be unique in the DTS. It has a data type, which is a QName. It has a period type, which can be either instant or duration. (optional) It has a balance type, which can be either credit or debit. (optional) It can be nillable, which is either true or false. If the attribute is not present, it defaults to false.","title":"Concept Objects"},{"location":"report-elements/concept/#get_name","text":"def get_name() -> QName Get the name of the concept. Returns : QName : the QName of the concept","title":"get_name"},{"location":"report-elements/concept/#get_labels","text":"def get_labels() -> list[BrelLabel] Get the labels of the concept. Returns : list[Label] : all labels of the concept","title":"get_labels"},{"location":"report-elements/concept/#get_period_type","text":"def get_period_type() -> str Get the period type of the concept. Returns : str : the period type of the concept","title":"get_period_type"},{"location":"report-elements/concept/#get_data_type","text":"def get_data_type() -> str Get the data type of the concept. Returns : str : the data type of the concept","title":"get_data_type"},{"location":"report-elements/concept/#get_balance_type","text":"def get_balance_type() -> str | None Get the balance type of the concept. Returns : str|None : the balance type of the concept. None if the concept has no balance type.","title":"get_balance_type"},{"location":"report-elements/concept/#is_nillable","text":"def is_nillable() -> bool Check if the concept is nillable. Returns : bool : True 'IFF' the concept is nillable, False otherwise","title":"is_nillable"},{"location":"report-elements/dimension/","text":"brel.reportelements.dimension This module contains the Dimension class. A dimension is a kind of report element that is used to present additional aspects for the context of a fact. Facts in Brel can already be viewed as a form of hypercube. Dimensions build on top of that and allow for custom dimensions to be added to the hypercube besides the already existing ones. The already existing dimensions are the core aspects of a fact, namely the period, the entity, the unit and the concept. ==================== author: Robin Schmidiger version: 0.3 date: 30 October 2023 ==================== Dimension Objects class Dimension(IReportElement) Class representing a dimension in a BREL report. A dimension is a kind of report element that is used to present additional aspects for the context of a fact. All dimensions are either explicit or typed. A new dimension is explicit by default. If you want to make a dimension typed, you have to call make_typed(dim_type: QName) on it. get_name def get_name() -> QName Get the name of the dimension. Returns : QName : the name of the dimension as a QName get_labels def get_labels() -> list[BrelLabel] Get the labels of the dimension. Returns : list[Label] : all labels of the dimension is_explicit def is_explicit() -> bool Check if the dimension is explicit. Use the make_typed(dim_type: QName) method to make a dimension typed. Returns : bool : True 'IFF' the dimension is explicit, False otherwise get_type def get_type() -> QName Get the type of the dimension. Raises : ValueError : if the dimension is explicit and has no type Use is_explicit() to check if the dimension is explicit. Returns : QName : type of the dimension make_typed def make_typed(dim_type: QName) Turn the dimension into a typed dimension. Arguments : dim_type : the type of the dimension. Has to be a QName","title":"Dimension"},{"location":"report-elements/dimension/#brelreportelementsdimension","text":"This module contains the Dimension class. A dimension is a kind of report element that is used to present additional aspects for the context of a fact. Facts in Brel can already be viewed as a form of hypercube. Dimensions build on top of that and allow for custom dimensions to be added to the hypercube besides the already existing ones. The already existing dimensions are the core aspects of a fact, namely the period, the entity, the unit and the concept. ==================== author: Robin Schmidiger version: 0.3 date: 30 October 2023 ====================","title":"brel.reportelements.dimension"},{"location":"report-elements/dimension/#dimension-objects","text":"class Dimension(IReportElement) Class representing a dimension in a BREL report. A dimension is a kind of report element that is used to present additional aspects for the context of a fact. All dimensions are either explicit or typed. A new dimension is explicit by default. If you want to make a dimension typed, you have to call make_typed(dim_type: QName) on it.","title":"Dimension Objects"},{"location":"report-elements/dimension/#get_name","text":"def get_name() -> QName Get the name of the dimension. Returns : QName : the name of the dimension as a QName","title":"get_name"},{"location":"report-elements/dimension/#get_labels","text":"def get_labels() -> list[BrelLabel] Get the labels of the dimension. Returns : list[Label] : all labels of the dimension","title":"get_labels"},{"location":"report-elements/dimension/#is_explicit","text":"def is_explicit() -> bool Check if the dimension is explicit. Use the make_typed(dim_type: QName) method to make a dimension typed. Returns : bool : True 'IFF' the dimension is explicit, False otherwise","title":"is_explicit"},{"location":"report-elements/dimension/#get_type","text":"def get_type() -> QName Get the type of the dimension. Raises : ValueError : if the dimension is explicit and has no type Use is_explicit() to check if the dimension is explicit. Returns : QName : type of the dimension","title":"get_type"},{"location":"report-elements/dimension/#make_typed","text":"def make_typed(dim_type: QName) Turn the dimension into a typed dimension. Arguments : dim_type : the type of the dimension. Has to be a QName","title":"make_typed"},{"location":"report-elements/hypercube/","text":"brel.reportelements.hypercube This module contains the Hypercube class. ================= author: Robin Schmidiger version: 0.2 date: 18 January 2024 ================= Hypercube Objects class Hypercube(IReportElement) get_name def get_name() -> QName @return QName: the name of the hypercube as a QName get_labels def get_labels() -> list[BrelLabel] @return list[BrelLabel]: the labels of the hypercube __str__ def __str__() -> str @return str: the name of the hypercube as a string","title":"Hypercube"},{"location":"report-elements/hypercube/#brelreportelementshypercube","text":"This module contains the Hypercube class. ================= author: Robin Schmidiger version: 0.2 date: 18 January 2024 =================","title":"brel.reportelements.hypercube"},{"location":"report-elements/hypercube/#hypercube-objects","text":"class Hypercube(IReportElement)","title":"Hypercube Objects"},{"location":"report-elements/hypercube/#get_name","text":"def get_name() -> QName @return QName: the name of the hypercube as a QName","title":"get_name"},{"location":"report-elements/hypercube/#get_labels","text":"def get_labels() -> list[BrelLabel] @return list[BrelLabel]: the labels of the hypercube","title":"get_labels"},{"location":"report-elements/hypercube/#__str__","text":"def __str__() -> str @return str: the name of the hypercube as a string","title":"__str__"},{"location":"report-elements/line-items/","text":"brel.reportelements.lineitems This module contains the LineItems class. ================= author: Robin Schmidiger version: 0.2 date: 18 January 2024 ================= LineItems Objects class LineItems(IReportElement) get_name def get_name() -> QName Returns : QName : the name of the line items as a QName get_labels def get_labels() -> list[BrelLabel] Returns : list[BrelLabel] : the labels of the line items __str__ def __str__() -> str Returns : str : the name of the line items as a string","title":"Line Items"},{"location":"report-elements/line-items/#brelreportelementslineitems","text":"This module contains the LineItems class. ================= author: Robin Schmidiger version: 0.2 date: 18 January 2024 =================","title":"brel.reportelements.lineitems"},{"location":"report-elements/line-items/#lineitems-objects","text":"class LineItems(IReportElement)","title":"LineItems Objects"},{"location":"report-elements/line-items/#get_name","text":"def get_name() -> QName Returns : QName : the name of the line items as a QName","title":"get_name"},{"location":"report-elements/line-items/#get_labels","text":"def get_labels() -> list[BrelLabel] Returns : list[BrelLabel] : the labels of the line items","title":"get_labels"},{"location":"report-elements/line-items/#__str__","text":"def __str__() -> str Returns : str : the name of the line items as a string","title":"__str__"},{"location":"report-elements/member/","text":"brel.reportelements.member This module contains the class for the Member report element in Brel. Members are used to represent the possible values of an explicit dimension. ==================== author: Robin Schmidiger version: 0.3 date: 18 January 2023 ==================== Member Objects class Member(IReportElement) Class representing a member in a BREL report. A member is a kind of report element that is used to represent the possible values of an explicit dimension. It implements the IReportElement interface. get_name def get_name() -> QName Returns : QName : the name of the member as a QName get_labels def get_labels() -> list[BrelLabel] Returns : list[BrelLabel] : the labels of the member","title":"Member"},{"location":"report-elements/member/#brelreportelementsmember","text":"This module contains the class for the Member report element in Brel. Members are used to represent the possible values of an explicit dimension. ==================== author: Robin Schmidiger version: 0.3 date: 18 January 2023 ====================","title":"brel.reportelements.member"},{"location":"report-elements/member/#member-objects","text":"class Member(IReportElement) Class representing a member in a BREL report. A member is a kind of report element that is used to represent the possible values of an explicit dimension. It implements the IReportElement interface.","title":"Member Objects"},{"location":"report-elements/member/#get_name","text":"def get_name() -> QName Returns : QName : the name of the member as a QName","title":"get_name"},{"location":"report-elements/member/#get_labels","text":"def get_labels() -> list[BrelLabel] Returns : list[BrelLabel] : the labels of the member","title":"get_labels"},{"location":"report-elements/report-elements/","text":"brel.reportelements.i_report_element This module contains the interface for all report elements. Report elements are the building blocks of a report and are used by a lot of other classes. Therefore, it is important to have a common interface for all report elements. Report have a unique name and can have multiple human readable labels representing the same name. Depending on the kind of report element, there might be more information available. ==================== author: Robin Schmidiger version: 0.2 date: 21 January 2024 ==================== IReportElement Objects class IReportElement(ABC) Interface for all report elements. Each report element must have a name and can have multiple labels. get_name @abstractmethod def get_name() -> QName Get the name of the report element. Returns : QName containing the name of the report element get_labels @abstractmethod def get_labels() -> list[BrelLabel] Get all labels of the report element. Returns : list[Label] : containing the labels of the report element has_label_with_role def has_label_with_role(label_role: str) -> bool Check if the report element has a label with the given role. Arguments : label_role : the role of the label to check Returns : bool : True if the report element has a label with the given role, False otherwise has_label_with_language def has_label_with_language(language: str) -> bool Check if the report element has a label with the given language. Arguments : language : the language of the label to check Returns : bool : True if the report element has a label with the given language, False otherwise","title":"Report Elements"},{"location":"report-elements/report-elements/#brelreportelementsi_report_element","text":"This module contains the interface for all report elements. Report elements are the building blocks of a report and are used by a lot of other classes. Therefore, it is important to have a common interface for all report elements. Report have a unique name and can have multiple human readable labels representing the same name. Depending on the kind of report element, there might be more information available. ==================== author: Robin Schmidiger version: 0.2 date: 21 January 2024 ====================","title":"brel.reportelements.i_report_element"},{"location":"report-elements/report-elements/#ireportelement-objects","text":"class IReportElement(ABC) Interface for all report elements. Each report element must have a name and can have multiple labels.","title":"IReportElement Objects"},{"location":"report-elements/report-elements/#get_name","text":"@abstractmethod def get_name() -> QName Get the name of the report element. Returns : QName containing the name of the report element","title":"get_name"},{"location":"report-elements/report-elements/#get_labels","text":"@abstractmethod def get_labels() -> list[BrelLabel] Get all labels of the report element. Returns : list[Label] : containing the labels of the report element","title":"get_labels"},{"location":"report-elements/report-elements/#has_label_with_role","text":"def has_label_with_role(label_role: str) -> bool Check if the report element has a label with the given role. Arguments : label_role : the role of the label to check Returns : bool : True if the report element has a label with the given role, False otherwise","title":"has_label_with_role"},{"location":"report-elements/report-elements/#has_label_with_language","text":"def has_label_with_language(language: str) -> bool Check if the report element has a label with the given language. Arguments : language : the language of the label to check Returns : bool : True if the report element has a label with the given language, False otherwise","title":"has_label_with_language"}]}