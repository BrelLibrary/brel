
\section{Implementation of QNames and namespace normalization}

\subsection{Overview}

As mentioned in chapter TODO, Brel leverages QNames to identify various elements across the XBRL taxonomy. 
QNames are a concept that is widely used in XML and XML-based languages, such as XBRL.
Thus, for most QNames in Brel, the necessary information can be directly extracted from the corresponding XML elements in the XBRL taxonomy.
However, there is an important difference between QNames in XML and QNames in Brel - Namespace bindings.

In XML documents, namespace bindings can be defined on a per-element basis. 
Child elements inherit the namespace bindings of their parent elements, unless they define their own namespace bindings. 
This allows for the construction of complex namespace hierarchies, where each element can have its own namespace bindings.
In Brel, however, namespace bindings are flat and defined on a global level.

The process of converting this hierarchical structure of namespace bindings into a flat structure is called namespace normalization.
Namespace normalization not only flattens the namespace hierarchy, but also resolves collisions in namespace bindings.

The motivation for having a flat structure of namespace bindings is that it makes it easier for users to search concepts, types, etc. in an XBRL filing using QNames.
Lets say a user wants to search for all facts that are associated with the concept \texttt{us-gaap:Assets} in the US GAAP taxonomy.

In Brel, the user can simply search for the QName \texttt{us-gaap:Assets} and will find all facts that are associated with this concept.
Brel will automatically resolve the prefix \texttt{us-gaap} to the corresponding namespace URI.
If the report uses the prefix \texttt{us-gaap1} instead of \texttt{us-gaap}, Brel will still be able to resolve the prefix to the correct namespace URI.

In XML, however, the prefix \texttt{us-gaap} might be bound to a different namespace URI in each element. 
Furthermore, the filer of the XBRL might choose to use the prefix \texttt{us-gaap1} in some sections of the XBRL taxonomy.
So if the user wants to search for all facts that are associated with the concept \texttt{us-gaap:Assets} in the US GAAP taxonomy, 
they would have to supply a context in which the prefix \texttt{us-gaap} is bound to the namespace URI of the US GAAP taxonomy.
But in another context, the same concept might be called \texttt{us-gaap1:Assets} instead.
This is extremely cumbersome for users and makes it very difficult to search for concepts, types, etc. in an XBRL filing using QNames.
It also insufficiantly shields users from the complexity of XML and XML-based languages, such as XBRL.

\subsection{Namespace hierarchy notation}

This section exclusively focuses on the implementation of QNames in Brel and namespace bindings in particular. 
Since XML documents tend to be very verbose and contain a lot of information that is not relevant for namespace bindings,
we will use a custom notation to represent namespace bindings in this section. 
I will refer to this notation as the \textit{namespace hierarchy notation} and describe it using an example.

The namespace hierarchy notation works as follows:

\begin{itemize}
    \item Each level of the namespace hierarchy is represented as a single line.
    \item Depending on the level of the namespace hierarchy, the element name has a different indentation.
    \item The name of the element is followed by a list of namespace bindings, separated by commas.
    \item Each namespace binding is represented as a key-value pair, where the key is the prefix of the namespace binding and the value is the namespace URI.
    \item If an element does not define any namespace bindings, the list of namespace bindings is omitted.
    \item XML attributes that are not namespace bindings are omitted in this notation.
\end{itemize}

Take the following XML snippet as an example:

% Example of an XML snipped where namespace bindings are defined on a per-element basis
\begin{figure}[H]
    \caption{Example of an XML snippet where namespace bindings are defined on a per-element basis}
    \label{fig:xml_namespace_notation_example}
    \begin{lstlisting}[language=XML]
        <element1 xmlns:foo = "http://foo.com" color = "red">
            <element2 xmlns:bar = "http://bar.com"/>
                <element3 color = "blue">
            </element2>
        </element1>
        <element4 xmlns:baz = "http://baz.com" xmlns:foo = "http://other-foo.com">
    \end{lstlisting}
\end{figure}

Using the namespace hierarchy notation, we can represent the same namespace hierarchy as follows:

% Example of the same XML snippet where namespace bindings are defined on a per-level basis
\begin{figure}[H]
    \caption{Example of the same XML snippet in our custom notation}
    \label{fig:custom_namespace_notation_example}
    \dirtree{%
    .1 root.
    .2 element1 foo = "http://foo.com".
    .3 element2 bar = "http://bar.com".
    .4 element3.
    .2 element4 baz = "http://baz.com", foo = "http://other-foo.com".
}
\end{figure}

As we can see, the namespace hierarchy notation is much more compact than the XML snippet.
The \texttt{color} attribute of \texttt{element1} and \texttt{element3} is omitted, since it is not a namespace binding.

\subsection{Flattening namespace bindings}

As mentioned in the previous section, namespace bindings in XML are defined on a per-element basis,
which is arranged in a tree structure.
In Brel, however, namespace bindings are defined on a global level, which is arranged in a flat structure.
Thus, we need to flatten the namespace hierarchy of the XBRL taxonomy into a flat structure.

The process of flattening a tree structure into a flat structure is a common problem in computer science.
One of the most common approaches to this problem is to use a depth-first search algorithm.
This is also the approach that we use in Brel to flatten the namespace hierarchy of the XBRL taxonomy.

Remember that in XML, child elements inherit the namespace bindings of their parent elements.
Thus, when flattening the namespace hierarchy, we need to make sure that
all the namespace bindings of a parent are also present in its children, 
unless the children define their own namespace bindings.

To give an example of flattening, let us flatten the namespace hierarchy from the previous figure TODO.

% Example of the same XML snippet where namespace bindings are defined on a per-level basis
\begin{figure}[H]
    \caption{Example of the same XML snippet in our custom notation, flattened}
    \label{fig:custom_namespace_notation_example_flattened}
    \dirtree{%
    .1 root.
    .2 element1 foo = "http://foo.com".
    .2 element2 foo = "http://foo.com", bar = "http://bar.com".
    .2 element3 foo = "http://foo.com", bar = "http://bar.com".
    .2 element4 baz = "http://baz.com", foo = "http://other-foo.com".
}
\end{figure}

As we can see, the namespace hierarchy has been flattened into a flat structure, meaning that all elements are on the same level.
The order of the elements is determined by the depth-first search algorithm.

Each child element inherits the namespace bindings of its parent element.
Thus, the \texttt{element2} and \texttt{element3} elements inherit the namespace bindings of the \texttt{element1} element.

To extract the namespace bindings of this flat structure, we can simply iterate over the elements and extract the namespace bindings of each element.
For our example, this would result in the following list of namespace bindings:

\begin{figure}
    \caption{List of namespace bindings extracted from the flattened namespace hierarchy}
    \label{fig:custom_namespace_notation_example_flattened_extracted}
    \begin{lstlisting}[language=XML]
        foo = "http://foo.com"
        bar = "http://bar.com"
        baz = "http://baz.com"
        foo = "http://other-foo.com"
    \end{lstlisting}
\end{figure}

\subsection{Collisions in namespace bindings}

An observant reader might have noticed that the list of namespace bindings from the previous section contains two bindings for the \texttt{foo} prefix.
The first binding is defined as \texttt{foo = "http://foo.com"}, whereas the second binding is defined as \texttt{foo = "http://other-foo.com"}.

This is called a collision and is not allowed in Brel.
The following section describes the different types of collisions and how they are handled in Brel.

\subsection{Types of collisions}

There are three types of collisions that can occur in Brel:

\begin{itemize}
    \item \textbf{Version collision}: Two namespace bindings have the same prefix and the same namespace URI, but different versions of it.
    
    Example: \texttt{foo = "http://foo.com/2022"} and \texttt{foo = "http://foo.com/2023"}
    \item \textbf{Prefix collision}: Two namespace bindings have the same prefix, but different \textit{unversioned} namespace URIs.
    
    Example: \texttt{foo = "http://foo.com"} and \texttt{foo = "http://other-foo.com"}
    \item \textbf{Namespace URI collision}: Two namespace bindings have the same \textit{unversioned} namespace URI, but different prefixes.
    
    Example: \texttt{foo = "http://foo.com"} and \texttt{bar = "http://foo.com"}
\end{itemize}

\subsubsection{Version collision}

Version collisions occur when two namespace bindings have the same prefix and the same namespace URI, but different versions of it.

Version collisions are allowed in brel, but they do raise an interesting question:
Lets say the creates a QName \texttt{foo:bar} to search for a concept in the taxonomy. 
Also assume that the XBRL filing contains the following namespace bindings:

\begin{figure}[H]
    \caption{Example of a version collision}
    \label{fig:version_collision_example}
    \dirtree{%
    .1 root.
    .2 element1 foo = "http://foo.com/01-01-2022".
    .3 foo:bar.
    .2 element2 foo = "http://foo.com/01-01-2023".
    .3 foo:baz.
}
\end{figure}

Which namespace URI should be used for the QName \texttt{foo:bar}?

The mechanism that Brel implements is straightforward: Use the newest version.

First, Brel will remove all digits, dashes and dots from the URI versions. 
If the two URI versions are equal after this step, then they are considered the same URI with different versions.
In our example, both URI versions transform into \texttt{http://foo.com/}.

Second, for each URI version, Brel will extract all numbers and compute their sum. The URI version with the higher sum is considered the newer version.
For our example, the sum of the first URI version is 2024, whereas the sum of the second URI version is 2025. 
Thus, the second URI version is considered the newer version. 
So if the user searches for the QName \texttt{foo:bar}, the URI version \texttt{http://foo.com/01-01-2023} will be used.

Even though this mechanism is straightforward, it does have some drawbacks. 
Namely, theoretically it is easy to trick the mechanism into using an older version of a namespace URI.
For example, the URI version \texttt{http://foo.com/31-12-2021} would be considered newer than \texttt{http://foo.com/01-01-2023}.

However, this is not a problem in practice since version collisions tend to be rare.
On top of that, most taxonomies are released on a yearly basis and their URI just contains the year of the release.
If the URI only contains the year, then the mechanism works as expected.

Furthermore, the mechanism used for searching and comparing QNames in Brel only uses the prefix and the local name of the QName.
Therefore, even if the mechanism would be tricked into using an older version of a namespace URI, it would not affect the search results.

\subsubsection{Prefix collision}

A prefix collision occurs when two namespace bindings have the same prefix, but different \textit{unversioned} namespace URIs.
The following figure shows an example of a prefix collision:

\begin{figure}[H]
    \caption{Example of a prefix collision}
    \label{fig:prefix_collision_example}
    \dirtree{%
    .1 root.
    .2 element1 foo = "http://foo.com".
    .3 foo:bar.
    .2 element2 foo = "http://other-foo.com".
    .3 foo:baz.
}
\end{figure}

Prefix collisions are not allowed in Brel. Brel will rename one of the prefixes to avoid the collision.
% In the case of our example above, Brel will rename the mapping \texttt{foo -> http://other-foo.com} to \texttt{foo1 -> http://other-foo.com} and will replace all appropriate QNames with the new prefix.
In the case of our example above, Brel will \texttt{element2}'s binding to \texttt{foo1 = "http://other-foo.com"} and will replace all appropriate QNames with the new prefix.

\begin{figure}[H]
    \caption{Example of a resolved prefix collision}
    \label{fig:prefix_collision_example_renamed}
    \dirtree{%
    .1 root.
    .2 element1 foo = "http://foo.com".
    .3 foo:bar.
    .2 element2 foo1 = "http://other-foo.com".
    .3 foo1:baz.
}
\end{figure}

If the user searches for a QName \texttt{foo:bar}, Brel will both search for \texttt{foo:bar} and \texttt{foo1:bar}.

\subsubsection{Namespace URI collision}

A namespace URI collision occurs when two namespace bindings have the same \textit{unversioned} namespace URI, 
but different prefixes.
% An example of this would be the namespace bindings \texttt{foo = "http://foo.com/2022"} and \texttt{bar = "http://foo.com/2023"}.
An example of a namespace URI collision is shown in the following figure:

\begin{figure}[H]
    \caption{Example of a namespace URI collision}
    \label{fig:namespace_uri_collision_example}
    \dirtree{%
    .1 root.
    .2 element1 foo = "http://foo.com".
    .3 foo:bar.
    .2 element2 bar = "http://foo.com".
    .3 bar:baz.
}
\end{figure}

Namespace URI collisions are not allowed in Brel. Brel will pick one of the two prefixes as the preferred prefix and will rename the other prefix to avoid the collision.
In general, Brel will pick the shorter prefix as the preferred prefix. If both have the same length, Brel will pick the prefix that comes first alphabetically.

% In the case of our example, brel will pick the prefix \texttt{bar} as the preferred prefix and will rename all occurences of \texttt{foo} to \texttt{bar}.
% Even if the user searches for the QName \texttt{foo:baz}, Brel will search for \texttt{bar:baz} instead.
In the case of our example, \texttt{bar} will be picked as the preferred prefix. 
Brel will rename the prefix \texttt{foo} along with all occurences to \texttt{bar}.

\begin{figure}[H]
    \caption{Example of a resolved namespace URI collision}
    \label{fig:namespace_uri_collision_example_renamed}
    \dirtree{%
    .1 root.
    .2 element1 bar = "http://foo.com".
    .3 bar:bar.
    .2 element2 bar = "http://foo.com".
    .3 bar:baz.
}
\end{figure}

There are some prefixes that are considered special and will always be picked as the preferred prefix, regardless of their length or alphabetical order.
These special prefixes do not even have to be defined in the XBRL taxonomy. 
If there is a namespace binding that points to the same namespace URI as one of the special prefixes, the special prefix will be picked as the preferred prefix.

The following prefixes are considered special:

\begin{figure}[H]
    \begin{itemize}
        \item \texttt{xml = "http://www.w3.org/XML/<year>/namespace"}
        \item \texttt{xlink = "http://www.w3.org/<year>/xlink"}
        \item \texttt{xs = "http://www.w3.org/<year>/XMLSchema"}
        \item \texttt{xsi = "http://www.w3.org/<year>/XMLSchema-instance"}
        \item \texttt{xbrli = "http://www.xbrl.org/<year>/instance"}
        \item TODO
    \end{itemize}
\end{figure}

If, for example, the XBRL filing contains a namespace binding \texttt{foo = "http://www.w3.org/2001/XMLSchema-instance"},
then the prefix \texttt{xsi} will be picked as the preferred prefix and all occurences of \texttt{foo} will be renamed to \texttt{xsi}.

The special prefixes and the corresponding namespace URIs can be configured in in the \texttt{nsconfig.json} file.